Grammar:

Rule 0     S' -> program
Rule 1     program -> empty
Rule 2     program -> statements
Rule 3     statements -> statements statement
Rule 4     statements -> statement
Rule 5     statement -> expr SEP
Rule 6     statement -> var_assign SEP
Rule 7     statement -> LET var : var_type SEP
Rule 8     statement -> var_define SEP
Rule 9     statement -> if_statement
Rule 10    statement -> for_statement
Rule 11    statement -> while_statement
Rule 12    statement -> return_statement
Rule 13    statement -> function_definition
Rule 14    var_type -> BOOL_TYPE
Rule 15    var_type -> STRING_TYPE
Rule 16    var_type -> FLOAT_TYPE
Rule 17    var_type -> INT_TYPE
Rule 18    function_definition -> FN ID ( params ) block
Rule 19    var_define -> LET var ASSIGN expr
Rule 20    return_statement -> RETURN expr SEP
Rule 21    var_assign -> DEC var  [precedence=right, level=11]
Rule 22    var_assign -> INC var  [precedence=right, level=11]
Rule 23    var_assign -> var MODULOASGN expr  [precedence=right, level=1]
Rule 24    var_assign -> var SLASHASGN expr  [precedence=right, level=1]
Rule 25    var_assign -> var STARASGN expr  [precedence=right, level=1]
Rule 26    var_assign -> var MINUSASGN expr  [precedence=right, level=1]
Rule 27    var_assign -> var PLUSASGN expr  [precedence=right, level=1]
Rule 28    var_assign -> var ASSIGN expr
Rule 29    if_statement -> IF expr block
Rule 30    if_statement -> IF expr block ELSE block
Rule 31    while_statement -> WHILE expr block
Rule 32    for_statement -> FOR var_assign SEP expr SEP var_assign block
Rule 33    expr -> var
Rule 34    expr -> FALSE
Rule 35    expr -> TRUE
Rule 36    expr -> STRING
Rule 37    expr -> FLOAT
Rule 38    expr -> INT
Rule 39    expr -> ( expr )
Rule 40    expr -> expr % expr  [precedence=left, level=10]
Rule 41    expr -> expr / expr  [precedence=left, level=10]
Rule 42    expr -> expr * expr  [precedence=left, level=10]
Rule 43    expr -> expr - expr  [precedence=left, level=9]
Rule 44    expr -> expr + expr  [precedence=left, level=9]
Rule 45    expr -> ! expr  [precedence=right, level=12]
Rule 46    expr -> + expr  [precedence=right, level=11]
Rule 47    expr -> - expr  [precedence=right, level=11]
Rule 48    expr -> expr | expr  [precedence=left, level=4]
Rule 49    expr -> expr ^ expr  [precedence=left, level=5]
Rule 50    expr -> expr & expr  [precedence=left, level=6]
Rule 51    expr -> expr GREATER expr  [precedence=left, level=8]
Rule 52    expr -> expr LESS expr  [precedence=left, level=8]
Rule 53    expr -> expr OR expr  [precedence=left, level=2]
Rule 54    expr -> expr AND expr  [precedence=left, level=3]
Rule 55    expr -> expr GREATEREQ expr  [precedence=left, level=8]
Rule 56    expr -> expr LESSEQ expr  [precedence=left, level=8]
Rule 57    expr -> expr NOTEQ expr  [precedence=left, level=7]
Rule 58    expr -> expr EQEQ expr  [precedence=left, level=7]
Rule 59    expr -> ID ( args )
Rule 60    expr -> expr ? expr : expr
Rule 61    var -> ID
Rule 62    empty -> <empty>
Rule 63    block -> statement
Rule 64    block -> { program }
Rule 65    params -> empty
Rule 66    params -> param
Rule 67    params -> params , param
Rule 68    param -> ID : var_type
Rule 69    args -> empty
Rule 70    args -> arg
Rule 71    args -> args , arg
Rule 72    arg -> expr

Terminals, with rules where they appear:

!                    : 45
%                    : 40
&                    : 50
(                    : 18 39 59
)                    : 18 39 59
*                    : 42
+                    : 44 46
,                    : 67 71
-                    : 43 47
/                    : 41
:                    : 7 60 68
?                    : 60
AND                  : 54
ASSIGN               : 19 28
BOOL_TYPE            : 14
DEC                  : 21
ELSE                 : 30
EQEQ                 : 58
FALSE                : 34
FLOAT                : 37
FLOAT_TYPE           : 16
FN                   : 18
FOR                  : 32
GREATER              : 51
GREATEREQ            : 55
ID                   : 18 59 61 68
IF                   : 29 30
INC                  : 22
INT                  : 38
INT_TYPE             : 17
LESS                 : 52
LESSEQ               : 56
LET                  : 7 19
MINUSASGN            : 26
MODULOASGN           : 23
NOTEQ                : 57
OR                   : 53
PLUSASGN             : 27
RETURN               : 20
SEP                  : 5 6 7 8 20 32 32
SLASHASGN            : 24
STARASGN             : 25
STRING               : 36
STRING_TYPE          : 15
TRUE                 : 35
WHILE                : 31
^                    : 49
error                : 
{                    : 64
|                    : 48
}                    : 64

Nonterminals, with rules where they appear:

arg                  : 70 71
args                 : 59 71
block                : 18 29 30 30 31 32
empty                : 1 65 69
expr                 : 5 19 20 23 24 25 26 27 28 29 30 31 32 39 40 40 41 41 42 42 43 43 44 44 45 46 47 48 48 49 49 50 50 51 51 52 52 53 53 54 54 55 55 56 56 57 57 58 58 60 60 60 72
for_statement        : 10
function_definition  : 13
if_statement         : 9
param                : 66 67
params               : 18 67
program              : 64 0
return_statement     : 12
statement            : 3 4 63
statements           : 2 3
var                  : 7 19 21 22 23 24 25 26 27 28 33
var_assign           : 6 32 32
var_define           : 8
var_type             : 7 68
while_statement      : 11


state 0

    (0) S' -> . program
    (1) program -> . empty
    (2) program -> . statements
    (62) empty -> .
    (3) statements -> . statements statement
    (4) statements -> . statement
    (5) statement -> . expr SEP
    (6) statement -> . var_assign SEP
    (7) statement -> . LET var : var_type SEP
    (8) statement -> . var_define SEP
    (9) statement -> . if_statement
    (10) statement -> . for_statement
    (11) statement -> . while_statement
    (12) statement -> . return_statement
    (13) statement -> . function_definition
    (33) expr -> . var
    (34) expr -> . FALSE
    (35) expr -> . TRUE
    (36) expr -> . STRING
    (37) expr -> . FLOAT
    (38) expr -> . INT
    (39) expr -> . ( expr )
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ! expr
    (46) expr -> . + expr
    (47) expr -> . - expr
    (48) expr -> . expr | expr
    (49) expr -> . expr ^ expr
    (50) expr -> . expr & expr
    (51) expr -> . expr GREATER expr
    (52) expr -> . expr LESS expr
    (53) expr -> . expr OR expr
    (54) expr -> . expr AND expr
    (55) expr -> . expr GREATEREQ expr
    (56) expr -> . expr LESSEQ expr
    (57) expr -> . expr NOTEQ expr
    (58) expr -> . expr EQEQ expr
    (59) expr -> . ID ( args )
    (60) expr -> . expr ? expr : expr
    (21) var_assign -> . DEC var
    (22) var_assign -> . INC var
    (23) var_assign -> . var MODULOASGN expr
    (24) var_assign -> . var SLASHASGN expr
    (25) var_assign -> . var STARASGN expr
    (26) var_assign -> . var MINUSASGN expr
    (27) var_assign -> . var PLUSASGN expr
    (28) var_assign -> . var ASSIGN expr
    (19) var_define -> . LET var ASSIGN expr
    (29) if_statement -> . IF expr block
    (30) if_statement -> . IF expr block ELSE block
    (32) for_statement -> . FOR var_assign SEP expr SEP var_assign block
    (31) while_statement -> . WHILE expr block
    (20) return_statement -> . RETURN expr SEP
    (18) function_definition -> . FN ID ( params ) block
    (61) var -> . ID
    $end            reduce using rule 62 (empty -> .)
    LET             shift and go to state 7
    FALSE           shift and go to state 15
    TRUE            shift and go to state 16
    STRING          shift and go to state 17
    FLOAT           shift and go to state 18
    INT             shift and go to state 19
    (               shift and go to state 20
    !               shift and go to state 23
    +               shift and go to state 22
    -               shift and go to state 21
    ID              shift and go to state 24
    DEC             shift and go to state 25
    INC             shift and go to state 26
    IF              shift and go to state 27
    FOR             shift and go to state 28
    WHILE           shift and go to state 29
    RETURN          shift and go to state 30
    FN              shift and go to state 31

    program                        shift and go to state 1
    empty                          shift and go to state 2
    statements                     shift and go to state 3
    statement                      shift and go to state 4
    expr                           shift and go to state 5
    var_assign                     shift and go to state 6
    var                            shift and go to state 8
    var_define                     shift and go to state 9
    if_statement                   shift and go to state 10
    for_statement                  shift and go to state 11
    while_statement                shift and go to state 12
    return_statement               shift and go to state 13
    function_definition            shift and go to state 14

state 1

    (0) S' -> program .


state 2

    (1) program -> empty .
    $end            reduce using rule 1 (program -> empty .)
    }               reduce using rule 1 (program -> empty .)


state 3

    (2) program -> statements .
    (3) statements -> statements . statement
    (5) statement -> . expr SEP
    (6) statement -> . var_assign SEP
    (7) statement -> . LET var : var_type SEP
    (8) statement -> . var_define SEP
    (9) statement -> . if_statement
    (10) statement -> . for_statement
    (11) statement -> . while_statement
    (12) statement -> . return_statement
    (13) statement -> . function_definition
    (33) expr -> . var
    (34) expr -> . FALSE
    (35) expr -> . TRUE
    (36) expr -> . STRING
    (37) expr -> . FLOAT
    (38) expr -> . INT
    (39) expr -> . ( expr )
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ! expr
    (46) expr -> . + expr
    (47) expr -> . - expr
    (48) expr -> . expr | expr
    (49) expr -> . expr ^ expr
    (50) expr -> . expr & expr
    (51) expr -> . expr GREATER expr
    (52) expr -> . expr LESS expr
    (53) expr -> . expr OR expr
    (54) expr -> . expr AND expr
    (55) expr -> . expr GREATEREQ expr
    (56) expr -> . expr LESSEQ expr
    (57) expr -> . expr NOTEQ expr
    (58) expr -> . expr EQEQ expr
    (59) expr -> . ID ( args )
    (60) expr -> . expr ? expr : expr
    (21) var_assign -> . DEC var
    (22) var_assign -> . INC var
    (23) var_assign -> . var MODULOASGN expr
    (24) var_assign -> . var SLASHASGN expr
    (25) var_assign -> . var STARASGN expr
    (26) var_assign -> . var MINUSASGN expr
    (27) var_assign -> . var PLUSASGN expr
    (28) var_assign -> . var ASSIGN expr
    (19) var_define -> . LET var ASSIGN expr
    (29) if_statement -> . IF expr block
    (30) if_statement -> . IF expr block ELSE block
    (32) for_statement -> . FOR var_assign SEP expr SEP var_assign block
    (31) while_statement -> . WHILE expr block
    (20) return_statement -> . RETURN expr SEP
    (18) function_definition -> . FN ID ( params ) block
    (61) var -> . ID
    $end            reduce using rule 2 (program -> statements .)
    }               reduce using rule 2 (program -> statements .)
    LET             shift and go to state 7
    FALSE           shift and go to state 15
    TRUE            shift and go to state 16
    STRING          shift and go to state 17
    FLOAT           shift and go to state 18
    INT             shift and go to state 19
    (               shift and go to state 20
    !               shift and go to state 23
    +               shift and go to state 22
    -               shift and go to state 21
    ID              shift and go to state 24
    DEC             shift and go to state 25
    INC             shift and go to state 26
    IF              shift and go to state 27
    FOR             shift and go to state 28
    WHILE           shift and go to state 29
    RETURN          shift and go to state 30
    FN              shift and go to state 31

    statement                      shift and go to state 32
    expr                           shift and go to state 5
    var_assign                     shift and go to state 6
    var                            shift and go to state 8
    var_define                     shift and go to state 9
    if_statement                   shift and go to state 10
    for_statement                  shift and go to state 11
    while_statement                shift and go to state 12
    return_statement               shift and go to state 13
    function_definition            shift and go to state 14

state 4

    (4) statements -> statement .
    LET             reduce using rule 4 (statements -> statement .)
    FALSE           reduce using rule 4 (statements -> statement .)
    TRUE            reduce using rule 4 (statements -> statement .)
    STRING          reduce using rule 4 (statements -> statement .)
    FLOAT           reduce using rule 4 (statements -> statement .)
    INT             reduce using rule 4 (statements -> statement .)
    (               reduce using rule 4 (statements -> statement .)
    !               reduce using rule 4 (statements -> statement .)
    +               reduce using rule 4 (statements -> statement .)
    -               reduce using rule 4 (statements -> statement .)
    ID              reduce using rule 4 (statements -> statement .)
    DEC             reduce using rule 4 (statements -> statement .)
    INC             reduce using rule 4 (statements -> statement .)
    IF              reduce using rule 4 (statements -> statement .)
    FOR             reduce using rule 4 (statements -> statement .)
    WHILE           reduce using rule 4 (statements -> statement .)
    RETURN          reduce using rule 4 (statements -> statement .)
    FN              reduce using rule 4 (statements -> statement .)
    $end            reduce using rule 4 (statements -> statement .)
    }               reduce using rule 4 (statements -> statement .)


state 5

    (5) statement -> expr . SEP
    (40) expr -> expr . % expr
    (41) expr -> expr . / expr
    (42) expr -> expr . * expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    (48) expr -> expr . | expr
    (49) expr -> expr . ^ expr
    (50) expr -> expr . & expr
    (51) expr -> expr . GREATER expr
    (52) expr -> expr . LESS expr
    (53) expr -> expr . OR expr
    (54) expr -> expr . AND expr
    (55) expr -> expr . GREATEREQ expr
    (56) expr -> expr . LESSEQ expr
    (57) expr -> expr . NOTEQ expr
    (58) expr -> expr . EQEQ expr
    (60) expr -> expr . ? expr : expr
    SEP             shift and go to state 33
    %               shift and go to state 34
    /               shift and go to state 35
    *               shift and go to state 36
    -               shift and go to state 37
    +               shift and go to state 38
    |               shift and go to state 39
    ^               shift and go to state 40
    &               shift and go to state 41
    GREATER         shift and go to state 42
    LESS            shift and go to state 43
    OR              shift and go to state 44
    AND             shift and go to state 45
    GREATEREQ       shift and go to state 46
    LESSEQ          shift and go to state 47
    NOTEQ           shift and go to state 48
    EQEQ            shift and go to state 49
    ?               shift and go to state 50


state 6

    (6) statement -> var_assign . SEP
    SEP             shift and go to state 51


state 7

    (7) statement -> LET . var : var_type SEP
    (19) var_define -> LET . var ASSIGN expr
    (61) var -> . ID
    ID              shift and go to state 53

    var                            shift and go to state 52

state 8

    (33) expr -> var .
    (23) var_assign -> var . MODULOASGN expr
    (24) var_assign -> var . SLASHASGN expr
    (25) var_assign -> var . STARASGN expr
    (26) var_assign -> var . MINUSASGN expr
    (27) var_assign -> var . PLUSASGN expr
    (28) var_assign -> var . ASSIGN expr
    SEP             reduce using rule 33 (expr -> var .)
    %               reduce using rule 33 (expr -> var .)
    /               reduce using rule 33 (expr -> var .)
    *               reduce using rule 33 (expr -> var .)
    -               reduce using rule 33 (expr -> var .)
    +               reduce using rule 33 (expr -> var .)
    |               reduce using rule 33 (expr -> var .)
    ^               reduce using rule 33 (expr -> var .)
    &               reduce using rule 33 (expr -> var .)
    GREATER         reduce using rule 33 (expr -> var .)
    LESS            reduce using rule 33 (expr -> var .)
    OR              reduce using rule 33 (expr -> var .)
    AND             reduce using rule 33 (expr -> var .)
    GREATEREQ       reduce using rule 33 (expr -> var .)
    LESSEQ          reduce using rule 33 (expr -> var .)
    NOTEQ           reduce using rule 33 (expr -> var .)
    EQEQ            reduce using rule 33 (expr -> var .)
    ?               reduce using rule 33 (expr -> var .)
    MODULOASGN      shift and go to state 54
    SLASHASGN       shift and go to state 55
    STARASGN        shift and go to state 56
    MINUSASGN       shift and go to state 57
    PLUSASGN        shift and go to state 58
    ASSIGN          shift and go to state 59


state 9

    (8) statement -> var_define . SEP
    SEP             shift and go to state 60


state 10

    (9) statement -> if_statement .
    LET             reduce using rule 9 (statement -> if_statement .)
    FALSE           reduce using rule 9 (statement -> if_statement .)
    TRUE            reduce using rule 9 (statement -> if_statement .)
    STRING          reduce using rule 9 (statement -> if_statement .)
    FLOAT           reduce using rule 9 (statement -> if_statement .)
    INT             reduce using rule 9 (statement -> if_statement .)
    (               reduce using rule 9 (statement -> if_statement .)
    !               reduce using rule 9 (statement -> if_statement .)
    +               reduce using rule 9 (statement -> if_statement .)
    -               reduce using rule 9 (statement -> if_statement .)
    ID              reduce using rule 9 (statement -> if_statement .)
    DEC             reduce using rule 9 (statement -> if_statement .)
    INC             reduce using rule 9 (statement -> if_statement .)
    IF              reduce using rule 9 (statement -> if_statement .)
    FOR             reduce using rule 9 (statement -> if_statement .)
    WHILE           reduce using rule 9 (statement -> if_statement .)
    RETURN          reduce using rule 9 (statement -> if_statement .)
    FN              reduce using rule 9 (statement -> if_statement .)
    $end            reduce using rule 9 (statement -> if_statement .)
    }               reduce using rule 9 (statement -> if_statement .)
    ELSE            reduce using rule 9 (statement -> if_statement .)


state 11

    (10) statement -> for_statement .
    LET             reduce using rule 10 (statement -> for_statement .)
    FALSE           reduce using rule 10 (statement -> for_statement .)
    TRUE            reduce using rule 10 (statement -> for_statement .)
    STRING          reduce using rule 10 (statement -> for_statement .)
    FLOAT           reduce using rule 10 (statement -> for_statement .)
    INT             reduce using rule 10 (statement -> for_statement .)
    (               reduce using rule 10 (statement -> for_statement .)
    !               reduce using rule 10 (statement -> for_statement .)
    +               reduce using rule 10 (statement -> for_statement .)
    -               reduce using rule 10 (statement -> for_statement .)
    ID              reduce using rule 10 (statement -> for_statement .)
    DEC             reduce using rule 10 (statement -> for_statement .)
    INC             reduce using rule 10 (statement -> for_statement .)
    IF              reduce using rule 10 (statement -> for_statement .)
    FOR             reduce using rule 10 (statement -> for_statement .)
    WHILE           reduce using rule 10 (statement -> for_statement .)
    RETURN          reduce using rule 10 (statement -> for_statement .)
    FN              reduce using rule 10 (statement -> for_statement .)
    $end            reduce using rule 10 (statement -> for_statement .)
    }               reduce using rule 10 (statement -> for_statement .)
    ELSE            reduce using rule 10 (statement -> for_statement .)


state 12

    (11) statement -> while_statement .
    LET             reduce using rule 11 (statement -> while_statement .)
    FALSE           reduce using rule 11 (statement -> while_statement .)
    TRUE            reduce using rule 11 (statement -> while_statement .)
    STRING          reduce using rule 11 (statement -> while_statement .)
    FLOAT           reduce using rule 11 (statement -> while_statement .)
    INT             reduce using rule 11 (statement -> while_statement .)
    (               reduce using rule 11 (statement -> while_statement .)
    !               reduce using rule 11 (statement -> while_statement .)
    +               reduce using rule 11 (statement -> while_statement .)
    -               reduce using rule 11 (statement -> while_statement .)
    ID              reduce using rule 11 (statement -> while_statement .)
    DEC             reduce using rule 11 (statement -> while_statement .)
    INC             reduce using rule 11 (statement -> while_statement .)
    IF              reduce using rule 11 (statement -> while_statement .)
    FOR             reduce using rule 11 (statement -> while_statement .)
    WHILE           reduce using rule 11 (statement -> while_statement .)
    RETURN          reduce using rule 11 (statement -> while_statement .)
    FN              reduce using rule 11 (statement -> while_statement .)
    $end            reduce using rule 11 (statement -> while_statement .)
    }               reduce using rule 11 (statement -> while_statement .)
    ELSE            reduce using rule 11 (statement -> while_statement .)


state 13

    (12) statement -> return_statement .
    LET             reduce using rule 12 (statement -> return_statement .)
    FALSE           reduce using rule 12 (statement -> return_statement .)
    TRUE            reduce using rule 12 (statement -> return_statement .)
    STRING          reduce using rule 12 (statement -> return_statement .)
    FLOAT           reduce using rule 12 (statement -> return_statement .)
    INT             reduce using rule 12 (statement -> return_statement .)
    (               reduce using rule 12 (statement -> return_statement .)
    !               reduce using rule 12 (statement -> return_statement .)
    +               reduce using rule 12 (statement -> return_statement .)
    -               reduce using rule 12 (statement -> return_statement .)
    ID              reduce using rule 12 (statement -> return_statement .)
    DEC             reduce using rule 12 (statement -> return_statement .)
    INC             reduce using rule 12 (statement -> return_statement .)
    IF              reduce using rule 12 (statement -> return_statement .)
    FOR             reduce using rule 12 (statement -> return_statement .)
    WHILE           reduce using rule 12 (statement -> return_statement .)
    RETURN          reduce using rule 12 (statement -> return_statement .)
    FN              reduce using rule 12 (statement -> return_statement .)
    $end            reduce using rule 12 (statement -> return_statement .)
    }               reduce using rule 12 (statement -> return_statement .)
    ELSE            reduce using rule 12 (statement -> return_statement .)


state 14

    (13) statement -> function_definition .
    LET             reduce using rule 13 (statement -> function_definition .)
    FALSE           reduce using rule 13 (statement -> function_definition .)
    TRUE            reduce using rule 13 (statement -> function_definition .)
    STRING          reduce using rule 13 (statement -> function_definition .)
    FLOAT           reduce using rule 13 (statement -> function_definition .)
    INT             reduce using rule 13 (statement -> function_definition .)
    (               reduce using rule 13 (statement -> function_definition .)
    !               reduce using rule 13 (statement -> function_definition .)
    +               reduce using rule 13 (statement -> function_definition .)
    -               reduce using rule 13 (statement -> function_definition .)
    ID              reduce using rule 13 (statement -> function_definition .)
    DEC             reduce using rule 13 (statement -> function_definition .)
    INC             reduce using rule 13 (statement -> function_definition .)
    IF              reduce using rule 13 (statement -> function_definition .)
    FOR             reduce using rule 13 (statement -> function_definition .)
    WHILE           reduce using rule 13 (statement -> function_definition .)
    RETURN          reduce using rule 13 (statement -> function_definition .)
    FN              reduce using rule 13 (statement -> function_definition .)
    $end            reduce using rule 13 (statement -> function_definition .)
    }               reduce using rule 13 (statement -> function_definition .)
    ELSE            reduce using rule 13 (statement -> function_definition .)


state 15

    (34) expr -> FALSE .
    SEP             reduce using rule 34 (expr -> FALSE .)
    %               reduce using rule 34 (expr -> FALSE .)
    /               reduce using rule 34 (expr -> FALSE .)
    *               reduce using rule 34 (expr -> FALSE .)
    -               reduce using rule 34 (expr -> FALSE .)
    +               reduce using rule 34 (expr -> FALSE .)
    |               reduce using rule 34 (expr -> FALSE .)
    ^               reduce using rule 34 (expr -> FALSE .)
    &               reduce using rule 34 (expr -> FALSE .)
    GREATER         reduce using rule 34 (expr -> FALSE .)
    LESS            reduce using rule 34 (expr -> FALSE .)
    OR              reduce using rule 34 (expr -> FALSE .)
    AND             reduce using rule 34 (expr -> FALSE .)
    GREATEREQ       reduce using rule 34 (expr -> FALSE .)
    LESSEQ          reduce using rule 34 (expr -> FALSE .)
    NOTEQ           reduce using rule 34 (expr -> FALSE .)
    EQEQ            reduce using rule 34 (expr -> FALSE .)
    ?               reduce using rule 34 (expr -> FALSE .)
    )               reduce using rule 34 (expr -> FALSE .)
    {               reduce using rule 34 (expr -> FALSE .)
    LET             reduce using rule 34 (expr -> FALSE .)
    FALSE           reduce using rule 34 (expr -> FALSE .)
    TRUE            reduce using rule 34 (expr -> FALSE .)
    STRING          reduce using rule 34 (expr -> FALSE .)
    FLOAT           reduce using rule 34 (expr -> FALSE .)
    INT             reduce using rule 34 (expr -> FALSE .)
    (               reduce using rule 34 (expr -> FALSE .)
    !               reduce using rule 34 (expr -> FALSE .)
    ID              reduce using rule 34 (expr -> FALSE .)
    DEC             reduce using rule 34 (expr -> FALSE .)
    INC             reduce using rule 34 (expr -> FALSE .)
    IF              reduce using rule 34 (expr -> FALSE .)
    FOR             reduce using rule 34 (expr -> FALSE .)
    WHILE           reduce using rule 34 (expr -> FALSE .)
    RETURN          reduce using rule 34 (expr -> FALSE .)
    FN              reduce using rule 34 (expr -> FALSE .)
    :               reduce using rule 34 (expr -> FALSE .)
    ,               reduce using rule 34 (expr -> FALSE .)


state 16

    (35) expr -> TRUE .
    SEP             reduce using rule 35 (expr -> TRUE .)
    %               reduce using rule 35 (expr -> TRUE .)
    /               reduce using rule 35 (expr -> TRUE .)
    *               reduce using rule 35 (expr -> TRUE .)
    -               reduce using rule 35 (expr -> TRUE .)
    +               reduce using rule 35 (expr -> TRUE .)
    |               reduce using rule 35 (expr -> TRUE .)
    ^               reduce using rule 35 (expr -> TRUE .)
    &               reduce using rule 35 (expr -> TRUE .)
    GREATER         reduce using rule 35 (expr -> TRUE .)
    LESS            reduce using rule 35 (expr -> TRUE .)
    OR              reduce using rule 35 (expr -> TRUE .)
    AND             reduce using rule 35 (expr -> TRUE .)
    GREATEREQ       reduce using rule 35 (expr -> TRUE .)
    LESSEQ          reduce using rule 35 (expr -> TRUE .)
    NOTEQ           reduce using rule 35 (expr -> TRUE .)
    EQEQ            reduce using rule 35 (expr -> TRUE .)
    ?               reduce using rule 35 (expr -> TRUE .)
    )               reduce using rule 35 (expr -> TRUE .)
    {               reduce using rule 35 (expr -> TRUE .)
    LET             reduce using rule 35 (expr -> TRUE .)
    FALSE           reduce using rule 35 (expr -> TRUE .)
    TRUE            reduce using rule 35 (expr -> TRUE .)
    STRING          reduce using rule 35 (expr -> TRUE .)
    FLOAT           reduce using rule 35 (expr -> TRUE .)
    INT             reduce using rule 35 (expr -> TRUE .)
    (               reduce using rule 35 (expr -> TRUE .)
    !               reduce using rule 35 (expr -> TRUE .)
    ID              reduce using rule 35 (expr -> TRUE .)
    DEC             reduce using rule 35 (expr -> TRUE .)
    INC             reduce using rule 35 (expr -> TRUE .)
    IF              reduce using rule 35 (expr -> TRUE .)
    FOR             reduce using rule 35 (expr -> TRUE .)
    WHILE           reduce using rule 35 (expr -> TRUE .)
    RETURN          reduce using rule 35 (expr -> TRUE .)
    FN              reduce using rule 35 (expr -> TRUE .)
    :               reduce using rule 35 (expr -> TRUE .)
    ,               reduce using rule 35 (expr -> TRUE .)


state 17

    (36) expr -> STRING .
    SEP             reduce using rule 36 (expr -> STRING .)
    %               reduce using rule 36 (expr -> STRING .)
    /               reduce using rule 36 (expr -> STRING .)
    *               reduce using rule 36 (expr -> STRING .)
    -               reduce using rule 36 (expr -> STRING .)
    +               reduce using rule 36 (expr -> STRING .)
    |               reduce using rule 36 (expr -> STRING .)
    ^               reduce using rule 36 (expr -> STRING .)
    &               reduce using rule 36 (expr -> STRING .)
    GREATER         reduce using rule 36 (expr -> STRING .)
    LESS            reduce using rule 36 (expr -> STRING .)
    OR              reduce using rule 36 (expr -> STRING .)
    AND             reduce using rule 36 (expr -> STRING .)
    GREATEREQ       reduce using rule 36 (expr -> STRING .)
    LESSEQ          reduce using rule 36 (expr -> STRING .)
    NOTEQ           reduce using rule 36 (expr -> STRING .)
    EQEQ            reduce using rule 36 (expr -> STRING .)
    ?               reduce using rule 36 (expr -> STRING .)
    )               reduce using rule 36 (expr -> STRING .)
    {               reduce using rule 36 (expr -> STRING .)
    LET             reduce using rule 36 (expr -> STRING .)
    FALSE           reduce using rule 36 (expr -> STRING .)
    TRUE            reduce using rule 36 (expr -> STRING .)
    STRING          reduce using rule 36 (expr -> STRING .)
    FLOAT           reduce using rule 36 (expr -> STRING .)
    INT             reduce using rule 36 (expr -> STRING .)
    (               reduce using rule 36 (expr -> STRING .)
    !               reduce using rule 36 (expr -> STRING .)
    ID              reduce using rule 36 (expr -> STRING .)
    DEC             reduce using rule 36 (expr -> STRING .)
    INC             reduce using rule 36 (expr -> STRING .)
    IF              reduce using rule 36 (expr -> STRING .)
    FOR             reduce using rule 36 (expr -> STRING .)
    WHILE           reduce using rule 36 (expr -> STRING .)
    RETURN          reduce using rule 36 (expr -> STRING .)
    FN              reduce using rule 36 (expr -> STRING .)
    :               reduce using rule 36 (expr -> STRING .)
    ,               reduce using rule 36 (expr -> STRING .)


state 18

    (37) expr -> FLOAT .
    SEP             reduce using rule 37 (expr -> FLOAT .)
    %               reduce using rule 37 (expr -> FLOAT .)
    /               reduce using rule 37 (expr -> FLOAT .)
    *               reduce using rule 37 (expr -> FLOAT .)
    -               reduce using rule 37 (expr -> FLOAT .)
    +               reduce using rule 37 (expr -> FLOAT .)
    |               reduce using rule 37 (expr -> FLOAT .)
    ^               reduce using rule 37 (expr -> FLOAT .)
    &               reduce using rule 37 (expr -> FLOAT .)
    GREATER         reduce using rule 37 (expr -> FLOAT .)
    LESS            reduce using rule 37 (expr -> FLOAT .)
    OR              reduce using rule 37 (expr -> FLOAT .)
    AND             reduce using rule 37 (expr -> FLOAT .)
    GREATEREQ       reduce using rule 37 (expr -> FLOAT .)
    LESSEQ          reduce using rule 37 (expr -> FLOAT .)
    NOTEQ           reduce using rule 37 (expr -> FLOAT .)
    EQEQ            reduce using rule 37 (expr -> FLOAT .)
    ?               reduce using rule 37 (expr -> FLOAT .)
    )               reduce using rule 37 (expr -> FLOAT .)
    {               reduce using rule 37 (expr -> FLOAT .)
    LET             reduce using rule 37 (expr -> FLOAT .)
    FALSE           reduce using rule 37 (expr -> FLOAT .)
    TRUE            reduce using rule 37 (expr -> FLOAT .)
    STRING          reduce using rule 37 (expr -> FLOAT .)
    FLOAT           reduce using rule 37 (expr -> FLOAT .)
    INT             reduce using rule 37 (expr -> FLOAT .)
    (               reduce using rule 37 (expr -> FLOAT .)
    !               reduce using rule 37 (expr -> FLOAT .)
    ID              reduce using rule 37 (expr -> FLOAT .)
    DEC             reduce using rule 37 (expr -> FLOAT .)
    INC             reduce using rule 37 (expr -> FLOAT .)
    IF              reduce using rule 37 (expr -> FLOAT .)
    FOR             reduce using rule 37 (expr -> FLOAT .)
    WHILE           reduce using rule 37 (expr -> FLOAT .)
    RETURN          reduce using rule 37 (expr -> FLOAT .)
    FN              reduce using rule 37 (expr -> FLOAT .)
    :               reduce using rule 37 (expr -> FLOAT .)
    ,               reduce using rule 37 (expr -> FLOAT .)


state 19

    (38) expr -> INT .
    SEP             reduce using rule 38 (expr -> INT .)
    %               reduce using rule 38 (expr -> INT .)
    /               reduce using rule 38 (expr -> INT .)
    *               reduce using rule 38 (expr -> INT .)
    -               reduce using rule 38 (expr -> INT .)
    +               reduce using rule 38 (expr -> INT .)
    |               reduce using rule 38 (expr -> INT .)
    ^               reduce using rule 38 (expr -> INT .)
    &               reduce using rule 38 (expr -> INT .)
    GREATER         reduce using rule 38 (expr -> INT .)
    LESS            reduce using rule 38 (expr -> INT .)
    OR              reduce using rule 38 (expr -> INT .)
    AND             reduce using rule 38 (expr -> INT .)
    GREATEREQ       reduce using rule 38 (expr -> INT .)
    LESSEQ          reduce using rule 38 (expr -> INT .)
    NOTEQ           reduce using rule 38 (expr -> INT .)
    EQEQ            reduce using rule 38 (expr -> INT .)
    ?               reduce using rule 38 (expr -> INT .)
    )               reduce using rule 38 (expr -> INT .)
    {               reduce using rule 38 (expr -> INT .)
    LET             reduce using rule 38 (expr -> INT .)
    FALSE           reduce using rule 38 (expr -> INT .)
    TRUE            reduce using rule 38 (expr -> INT .)
    STRING          reduce using rule 38 (expr -> INT .)
    FLOAT           reduce using rule 38 (expr -> INT .)
    INT             reduce using rule 38 (expr -> INT .)
    (               reduce using rule 38 (expr -> INT .)
    !               reduce using rule 38 (expr -> INT .)
    ID              reduce using rule 38 (expr -> INT .)
    DEC             reduce using rule 38 (expr -> INT .)
    INC             reduce using rule 38 (expr -> INT .)
    IF              reduce using rule 38 (expr -> INT .)
    FOR             reduce using rule 38 (expr -> INT .)
    WHILE           reduce using rule 38 (expr -> INT .)
    RETURN          reduce using rule 38 (expr -> INT .)
    FN              reduce using rule 38 (expr -> INT .)
    :               reduce using rule 38 (expr -> INT .)
    ,               reduce using rule 38 (expr -> INT .)


state 20

    (39) expr -> ( . expr )
    (33) expr -> . var
    (34) expr -> . FALSE
    (35) expr -> . TRUE
    (36) expr -> . STRING
    (37) expr -> . FLOAT
    (38) expr -> . INT
    (39) expr -> . ( expr )
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ! expr
    (46) expr -> . + expr
    (47) expr -> . - expr
    (48) expr -> . expr | expr
    (49) expr -> . expr ^ expr
    (50) expr -> . expr & expr
    (51) expr -> . expr GREATER expr
    (52) expr -> . expr LESS expr
    (53) expr -> . expr OR expr
    (54) expr -> . expr AND expr
    (55) expr -> . expr GREATEREQ expr
    (56) expr -> . expr LESSEQ expr
    (57) expr -> . expr NOTEQ expr
    (58) expr -> . expr EQEQ expr
    (59) expr -> . ID ( args )
    (60) expr -> . expr ? expr : expr
    (61) var -> . ID
    FALSE           shift and go to state 15
    TRUE            shift and go to state 16
    STRING          shift and go to state 17
    FLOAT           shift and go to state 18
    INT             shift and go to state 19
    (               shift and go to state 20
    !               shift and go to state 23
    +               shift and go to state 22
    -               shift and go to state 21
    ID              shift and go to state 24

    expr                           shift and go to state 61
    var                            shift and go to state 62

state 21

    (47) expr -> - . expr
    (33) expr -> . var
    (34) expr -> . FALSE
    (35) expr -> . TRUE
    (36) expr -> . STRING
    (37) expr -> . FLOAT
    (38) expr -> . INT
    (39) expr -> . ( expr )
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ! expr
    (46) expr -> . + expr
    (47) expr -> . - expr
    (48) expr -> . expr | expr
    (49) expr -> . expr ^ expr
    (50) expr -> . expr & expr
    (51) expr -> . expr GREATER expr
    (52) expr -> . expr LESS expr
    (53) expr -> . expr OR expr
    (54) expr -> . expr AND expr
    (55) expr -> . expr GREATEREQ expr
    (56) expr -> . expr LESSEQ expr
    (57) expr -> . expr NOTEQ expr
    (58) expr -> . expr EQEQ expr
    (59) expr -> . ID ( args )
    (60) expr -> . expr ? expr : expr
    (61) var -> . ID
    FALSE           shift and go to state 15
    TRUE            shift and go to state 16
    STRING          shift and go to state 17
    FLOAT           shift and go to state 18
    INT             shift and go to state 19
    (               shift and go to state 20
    !               shift and go to state 23
    +               shift and go to state 22
    -               shift and go to state 21
    ID              shift and go to state 24

    expr                           shift and go to state 63
    var                            shift and go to state 62

state 22

    (46) expr -> + . expr
    (33) expr -> . var
    (34) expr -> . FALSE
    (35) expr -> . TRUE
    (36) expr -> . STRING
    (37) expr -> . FLOAT
    (38) expr -> . INT
    (39) expr -> . ( expr )
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ! expr
    (46) expr -> . + expr
    (47) expr -> . - expr
    (48) expr -> . expr | expr
    (49) expr -> . expr ^ expr
    (50) expr -> . expr & expr
    (51) expr -> . expr GREATER expr
    (52) expr -> . expr LESS expr
    (53) expr -> . expr OR expr
    (54) expr -> . expr AND expr
    (55) expr -> . expr GREATEREQ expr
    (56) expr -> . expr LESSEQ expr
    (57) expr -> . expr NOTEQ expr
    (58) expr -> . expr EQEQ expr
    (59) expr -> . ID ( args )
    (60) expr -> . expr ? expr : expr
    (61) var -> . ID
    FALSE           shift and go to state 15
    TRUE            shift and go to state 16
    STRING          shift and go to state 17
    FLOAT           shift and go to state 18
    INT             shift and go to state 19
    (               shift and go to state 20
    !               shift and go to state 23
    +               shift and go to state 22
    -               shift and go to state 21
    ID              shift and go to state 24

    expr                           shift and go to state 64
    var                            shift and go to state 62

state 23

    (45) expr -> ! . expr
    (33) expr -> . var
    (34) expr -> . FALSE
    (35) expr -> . TRUE
    (36) expr -> . STRING
    (37) expr -> . FLOAT
    (38) expr -> . INT
    (39) expr -> . ( expr )
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ! expr
    (46) expr -> . + expr
    (47) expr -> . - expr
    (48) expr -> . expr | expr
    (49) expr -> . expr ^ expr
    (50) expr -> . expr & expr
    (51) expr -> . expr GREATER expr
    (52) expr -> . expr LESS expr
    (53) expr -> . expr OR expr
    (54) expr -> . expr AND expr
    (55) expr -> . expr GREATEREQ expr
    (56) expr -> . expr LESSEQ expr
    (57) expr -> . expr NOTEQ expr
    (58) expr -> . expr EQEQ expr
    (59) expr -> . ID ( args )
    (60) expr -> . expr ? expr : expr
    (61) var -> . ID
    FALSE           shift and go to state 15
    TRUE            shift and go to state 16
    STRING          shift and go to state 17
    FLOAT           shift and go to state 18
    INT             shift and go to state 19
    (               shift and go to state 20
    !               shift and go to state 23
    +               shift and go to state 22
    -               shift and go to state 21
    ID              shift and go to state 24

    expr                           shift and go to state 65
    var                            shift and go to state 62

state 24

    (59) expr -> ID . ( args )
    (61) var -> ID .
  ! shift/reduce conflict for ( resolved as shift
    (               shift and go to state 66
    MODULOASGN      reduce using rule 61 (var -> ID .)
    SLASHASGN       reduce using rule 61 (var -> ID .)
    STARASGN        reduce using rule 61 (var -> ID .)
    MINUSASGN       reduce using rule 61 (var -> ID .)
    PLUSASGN        reduce using rule 61 (var -> ID .)
    ASSIGN          reduce using rule 61 (var -> ID .)
    SEP             reduce using rule 61 (var -> ID .)
    %               reduce using rule 61 (var -> ID .)
    /               reduce using rule 61 (var -> ID .)
    *               reduce using rule 61 (var -> ID .)
    -               reduce using rule 61 (var -> ID .)
    +               reduce using rule 61 (var -> ID .)
    |               reduce using rule 61 (var -> ID .)
    ^               reduce using rule 61 (var -> ID .)
    &               reduce using rule 61 (var -> ID .)
    GREATER         reduce using rule 61 (var -> ID .)
    LESS            reduce using rule 61 (var -> ID .)
    OR              reduce using rule 61 (var -> ID .)
    AND             reduce using rule 61 (var -> ID .)
    GREATEREQ       reduce using rule 61 (var -> ID .)
    LESSEQ          reduce using rule 61 (var -> ID .)
    NOTEQ           reduce using rule 61 (var -> ID .)
    EQEQ            reduce using rule 61 (var -> ID .)
    ?               reduce using rule 61 (var -> ID .)
    )               reduce using rule 61 (var -> ID .)
    {               reduce using rule 61 (var -> ID .)
    LET             reduce using rule 61 (var -> ID .)
    FALSE           reduce using rule 61 (var -> ID .)
    TRUE            reduce using rule 61 (var -> ID .)
    STRING          reduce using rule 61 (var -> ID .)
    FLOAT           reduce using rule 61 (var -> ID .)
    INT             reduce using rule 61 (var -> ID .)
    !               reduce using rule 61 (var -> ID .)
    ID              reduce using rule 61 (var -> ID .)
    DEC             reduce using rule 61 (var -> ID .)
    INC             reduce using rule 61 (var -> ID .)
    IF              reduce using rule 61 (var -> ID .)
    FOR             reduce using rule 61 (var -> ID .)
    WHILE           reduce using rule 61 (var -> ID .)
    RETURN          reduce using rule 61 (var -> ID .)
    FN              reduce using rule 61 (var -> ID .)
    :               reduce using rule 61 (var -> ID .)
    ,               reduce using rule 61 (var -> ID .)


state 25

    (21) var_assign -> DEC . var
    (61) var -> . ID
    ID              shift and go to state 53

    var                            shift and go to state 67

state 26

    (22) var_assign -> INC . var
    (61) var -> . ID
    ID              shift and go to state 53

    var                            shift and go to state 68

state 27

    (29) if_statement -> IF . expr block
    (30) if_statement -> IF . expr block ELSE block
    (33) expr -> . var
    (34) expr -> . FALSE
    (35) expr -> . TRUE
    (36) expr -> . STRING
    (37) expr -> . FLOAT
    (38) expr -> . INT
    (39) expr -> . ( expr )
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ! expr
    (46) expr -> . + expr
    (47) expr -> . - expr
    (48) expr -> . expr | expr
    (49) expr -> . expr ^ expr
    (50) expr -> . expr & expr
    (51) expr -> . expr GREATER expr
    (52) expr -> . expr LESS expr
    (53) expr -> . expr OR expr
    (54) expr -> . expr AND expr
    (55) expr -> . expr GREATEREQ expr
    (56) expr -> . expr LESSEQ expr
    (57) expr -> . expr NOTEQ expr
    (58) expr -> . expr EQEQ expr
    (59) expr -> . ID ( args )
    (60) expr -> . expr ? expr : expr
    (61) var -> . ID
    FALSE           shift and go to state 15
    TRUE            shift and go to state 16
    STRING          shift and go to state 17
    FLOAT           shift and go to state 18
    INT             shift and go to state 19
    (               shift and go to state 20
    !               shift and go to state 23
    +               shift and go to state 22
    -               shift and go to state 21
    ID              shift and go to state 24

    expr                           shift and go to state 69
    var                            shift and go to state 62

state 28

    (32) for_statement -> FOR . var_assign SEP expr SEP var_assign block
    (21) var_assign -> . DEC var
    (22) var_assign -> . INC var
    (23) var_assign -> . var MODULOASGN expr
    (24) var_assign -> . var SLASHASGN expr
    (25) var_assign -> . var STARASGN expr
    (26) var_assign -> . var MINUSASGN expr
    (27) var_assign -> . var PLUSASGN expr
    (28) var_assign -> . var ASSIGN expr
    (61) var -> . ID
    DEC             shift and go to state 25
    INC             shift and go to state 26
    ID              shift and go to state 53

    var_assign                     shift and go to state 70
    var                            shift and go to state 71

state 29

    (31) while_statement -> WHILE . expr block
    (33) expr -> . var
    (34) expr -> . FALSE
    (35) expr -> . TRUE
    (36) expr -> . STRING
    (37) expr -> . FLOAT
    (38) expr -> . INT
    (39) expr -> . ( expr )
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ! expr
    (46) expr -> . + expr
    (47) expr -> . - expr
    (48) expr -> . expr | expr
    (49) expr -> . expr ^ expr
    (50) expr -> . expr & expr
    (51) expr -> . expr GREATER expr
    (52) expr -> . expr LESS expr
    (53) expr -> . expr OR expr
    (54) expr -> . expr AND expr
    (55) expr -> . expr GREATEREQ expr
    (56) expr -> . expr LESSEQ expr
    (57) expr -> . expr NOTEQ expr
    (58) expr -> . expr EQEQ expr
    (59) expr -> . ID ( args )
    (60) expr -> . expr ? expr : expr
    (61) var -> . ID
    FALSE           shift and go to state 15
    TRUE            shift and go to state 16
    STRING          shift and go to state 17
    FLOAT           shift and go to state 18
    INT             shift and go to state 19
    (               shift and go to state 20
    !               shift and go to state 23
    +               shift and go to state 22
    -               shift and go to state 21
    ID              shift and go to state 24

    expr                           shift and go to state 72
    var                            shift and go to state 62

state 30

    (20) return_statement -> RETURN . expr SEP
    (33) expr -> . var
    (34) expr -> . FALSE
    (35) expr -> . TRUE
    (36) expr -> . STRING
    (37) expr -> . FLOAT
    (38) expr -> . INT
    (39) expr -> . ( expr )
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ! expr
    (46) expr -> . + expr
    (47) expr -> . - expr
    (48) expr -> . expr | expr
    (49) expr -> . expr ^ expr
    (50) expr -> . expr & expr
    (51) expr -> . expr GREATER expr
    (52) expr -> . expr LESS expr
    (53) expr -> . expr OR expr
    (54) expr -> . expr AND expr
    (55) expr -> . expr GREATEREQ expr
    (56) expr -> . expr LESSEQ expr
    (57) expr -> . expr NOTEQ expr
    (58) expr -> . expr EQEQ expr
    (59) expr -> . ID ( args )
    (60) expr -> . expr ? expr : expr
    (61) var -> . ID
    FALSE           shift and go to state 15
    TRUE            shift and go to state 16
    STRING          shift and go to state 17
    FLOAT           shift and go to state 18
    INT             shift and go to state 19
    (               shift and go to state 20
    !               shift and go to state 23
    +               shift and go to state 22
    -               shift and go to state 21
    ID              shift and go to state 24

    expr                           shift and go to state 73
    var                            shift and go to state 62

state 31

    (18) function_definition -> FN . ID ( params ) block
    ID              shift and go to state 74


state 32

    (3) statements -> statements statement .
    LET             reduce using rule 3 (statements -> statements statement .)
    FALSE           reduce using rule 3 (statements -> statements statement .)
    TRUE            reduce using rule 3 (statements -> statements statement .)
    STRING          reduce using rule 3 (statements -> statements statement .)
    FLOAT           reduce using rule 3 (statements -> statements statement .)
    INT             reduce using rule 3 (statements -> statements statement .)
    (               reduce using rule 3 (statements -> statements statement .)
    !               reduce using rule 3 (statements -> statements statement .)
    +               reduce using rule 3 (statements -> statements statement .)
    -               reduce using rule 3 (statements -> statements statement .)
    ID              reduce using rule 3 (statements -> statements statement .)
    DEC             reduce using rule 3 (statements -> statements statement .)
    INC             reduce using rule 3 (statements -> statements statement .)
    IF              reduce using rule 3 (statements -> statements statement .)
    FOR             reduce using rule 3 (statements -> statements statement .)
    WHILE           reduce using rule 3 (statements -> statements statement .)
    RETURN          reduce using rule 3 (statements -> statements statement .)
    FN              reduce using rule 3 (statements -> statements statement .)
    $end            reduce using rule 3 (statements -> statements statement .)
    }               reduce using rule 3 (statements -> statements statement .)


state 33

    (5) statement -> expr SEP .
    LET             reduce using rule 5 (statement -> expr SEP .)
    FALSE           reduce using rule 5 (statement -> expr SEP .)
    TRUE            reduce using rule 5 (statement -> expr SEP .)
    STRING          reduce using rule 5 (statement -> expr SEP .)
    FLOAT           reduce using rule 5 (statement -> expr SEP .)
    INT             reduce using rule 5 (statement -> expr SEP .)
    (               reduce using rule 5 (statement -> expr SEP .)
    !               reduce using rule 5 (statement -> expr SEP .)
    +               reduce using rule 5 (statement -> expr SEP .)
    -               reduce using rule 5 (statement -> expr SEP .)
    ID              reduce using rule 5 (statement -> expr SEP .)
    DEC             reduce using rule 5 (statement -> expr SEP .)
    INC             reduce using rule 5 (statement -> expr SEP .)
    IF              reduce using rule 5 (statement -> expr SEP .)
    FOR             reduce using rule 5 (statement -> expr SEP .)
    WHILE           reduce using rule 5 (statement -> expr SEP .)
    RETURN          reduce using rule 5 (statement -> expr SEP .)
    FN              reduce using rule 5 (statement -> expr SEP .)
    $end            reduce using rule 5 (statement -> expr SEP .)
    }               reduce using rule 5 (statement -> expr SEP .)
    ELSE            reduce using rule 5 (statement -> expr SEP .)


state 34

    (40) expr -> expr % . expr
    (33) expr -> . var
    (34) expr -> . FALSE
    (35) expr -> . TRUE
    (36) expr -> . STRING
    (37) expr -> . FLOAT
    (38) expr -> . INT
    (39) expr -> . ( expr )
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ! expr
    (46) expr -> . + expr
    (47) expr -> . - expr
    (48) expr -> . expr | expr
    (49) expr -> . expr ^ expr
    (50) expr -> . expr & expr
    (51) expr -> . expr GREATER expr
    (52) expr -> . expr LESS expr
    (53) expr -> . expr OR expr
    (54) expr -> . expr AND expr
    (55) expr -> . expr GREATEREQ expr
    (56) expr -> . expr LESSEQ expr
    (57) expr -> . expr NOTEQ expr
    (58) expr -> . expr EQEQ expr
    (59) expr -> . ID ( args )
    (60) expr -> . expr ? expr : expr
    (61) var -> . ID
    FALSE           shift and go to state 15
    TRUE            shift and go to state 16
    STRING          shift and go to state 17
    FLOAT           shift and go to state 18
    INT             shift and go to state 19
    (               shift and go to state 20
    !               shift and go to state 23
    +               shift and go to state 22
    -               shift and go to state 21
    ID              shift and go to state 24

    expr                           shift and go to state 75
    var                            shift and go to state 62

state 35

    (41) expr -> expr / . expr
    (33) expr -> . var
    (34) expr -> . FALSE
    (35) expr -> . TRUE
    (36) expr -> . STRING
    (37) expr -> . FLOAT
    (38) expr -> . INT
    (39) expr -> . ( expr )
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ! expr
    (46) expr -> . + expr
    (47) expr -> . - expr
    (48) expr -> . expr | expr
    (49) expr -> . expr ^ expr
    (50) expr -> . expr & expr
    (51) expr -> . expr GREATER expr
    (52) expr -> . expr LESS expr
    (53) expr -> . expr OR expr
    (54) expr -> . expr AND expr
    (55) expr -> . expr GREATEREQ expr
    (56) expr -> . expr LESSEQ expr
    (57) expr -> . expr NOTEQ expr
    (58) expr -> . expr EQEQ expr
    (59) expr -> . ID ( args )
    (60) expr -> . expr ? expr : expr
    (61) var -> . ID
    FALSE           shift and go to state 15
    TRUE            shift and go to state 16
    STRING          shift and go to state 17
    FLOAT           shift and go to state 18
    INT             shift and go to state 19
    (               shift and go to state 20
    !               shift and go to state 23
    +               shift and go to state 22
    -               shift and go to state 21
    ID              shift and go to state 24

    expr                           shift and go to state 76
    var                            shift and go to state 62

state 36

    (42) expr -> expr * . expr
    (33) expr -> . var
    (34) expr -> . FALSE
    (35) expr -> . TRUE
    (36) expr -> . STRING
    (37) expr -> . FLOAT
    (38) expr -> . INT
    (39) expr -> . ( expr )
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ! expr
    (46) expr -> . + expr
    (47) expr -> . - expr
    (48) expr -> . expr | expr
    (49) expr -> . expr ^ expr
    (50) expr -> . expr & expr
    (51) expr -> . expr GREATER expr
    (52) expr -> . expr LESS expr
    (53) expr -> . expr OR expr
    (54) expr -> . expr AND expr
    (55) expr -> . expr GREATEREQ expr
    (56) expr -> . expr LESSEQ expr
    (57) expr -> . expr NOTEQ expr
    (58) expr -> . expr EQEQ expr
    (59) expr -> . ID ( args )
    (60) expr -> . expr ? expr : expr
    (61) var -> . ID
    FALSE           shift and go to state 15
    TRUE            shift and go to state 16
    STRING          shift and go to state 17
    FLOAT           shift and go to state 18
    INT             shift and go to state 19
    (               shift and go to state 20
    !               shift and go to state 23
    +               shift and go to state 22
    -               shift and go to state 21
    ID              shift and go to state 24

    expr                           shift and go to state 77
    var                            shift and go to state 62

state 37

    (43) expr -> expr - . expr
    (33) expr -> . var
    (34) expr -> . FALSE
    (35) expr -> . TRUE
    (36) expr -> . STRING
    (37) expr -> . FLOAT
    (38) expr -> . INT
    (39) expr -> . ( expr )
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ! expr
    (46) expr -> . + expr
    (47) expr -> . - expr
    (48) expr -> . expr | expr
    (49) expr -> . expr ^ expr
    (50) expr -> . expr & expr
    (51) expr -> . expr GREATER expr
    (52) expr -> . expr LESS expr
    (53) expr -> . expr OR expr
    (54) expr -> . expr AND expr
    (55) expr -> . expr GREATEREQ expr
    (56) expr -> . expr LESSEQ expr
    (57) expr -> . expr NOTEQ expr
    (58) expr -> . expr EQEQ expr
    (59) expr -> . ID ( args )
    (60) expr -> . expr ? expr : expr
    (61) var -> . ID
    FALSE           shift and go to state 15
    TRUE            shift and go to state 16
    STRING          shift and go to state 17
    FLOAT           shift and go to state 18
    INT             shift and go to state 19
    (               shift and go to state 20
    !               shift and go to state 23
    +               shift and go to state 22
    -               shift and go to state 21
    ID              shift and go to state 24

    expr                           shift and go to state 78
    var                            shift and go to state 62

state 38

    (44) expr -> expr + . expr
    (33) expr -> . var
    (34) expr -> . FALSE
    (35) expr -> . TRUE
    (36) expr -> . STRING
    (37) expr -> . FLOAT
    (38) expr -> . INT
    (39) expr -> . ( expr )
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ! expr
    (46) expr -> . + expr
    (47) expr -> . - expr
    (48) expr -> . expr | expr
    (49) expr -> . expr ^ expr
    (50) expr -> . expr & expr
    (51) expr -> . expr GREATER expr
    (52) expr -> . expr LESS expr
    (53) expr -> . expr OR expr
    (54) expr -> . expr AND expr
    (55) expr -> . expr GREATEREQ expr
    (56) expr -> . expr LESSEQ expr
    (57) expr -> . expr NOTEQ expr
    (58) expr -> . expr EQEQ expr
    (59) expr -> . ID ( args )
    (60) expr -> . expr ? expr : expr
    (61) var -> . ID
    FALSE           shift and go to state 15
    TRUE            shift and go to state 16
    STRING          shift and go to state 17
    FLOAT           shift and go to state 18
    INT             shift and go to state 19
    (               shift and go to state 20
    !               shift and go to state 23
    +               shift and go to state 22
    -               shift and go to state 21
    ID              shift and go to state 24

    expr                           shift and go to state 79
    var                            shift and go to state 62

state 39

    (48) expr -> expr | . expr
    (33) expr -> . var
    (34) expr -> . FALSE
    (35) expr -> . TRUE
    (36) expr -> . STRING
    (37) expr -> . FLOAT
    (38) expr -> . INT
    (39) expr -> . ( expr )
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ! expr
    (46) expr -> . + expr
    (47) expr -> . - expr
    (48) expr -> . expr | expr
    (49) expr -> . expr ^ expr
    (50) expr -> . expr & expr
    (51) expr -> . expr GREATER expr
    (52) expr -> . expr LESS expr
    (53) expr -> . expr OR expr
    (54) expr -> . expr AND expr
    (55) expr -> . expr GREATEREQ expr
    (56) expr -> . expr LESSEQ expr
    (57) expr -> . expr NOTEQ expr
    (58) expr -> . expr EQEQ expr
    (59) expr -> . ID ( args )
    (60) expr -> . expr ? expr : expr
    (61) var -> . ID
    FALSE           shift and go to state 15
    TRUE            shift and go to state 16
    STRING          shift and go to state 17
    FLOAT           shift and go to state 18
    INT             shift and go to state 19
    (               shift and go to state 20
    !               shift and go to state 23
    +               shift and go to state 22
    -               shift and go to state 21
    ID              shift and go to state 24

    expr                           shift and go to state 80
    var                            shift and go to state 62

state 40

    (49) expr -> expr ^ . expr
    (33) expr -> . var
    (34) expr -> . FALSE
    (35) expr -> . TRUE
    (36) expr -> . STRING
    (37) expr -> . FLOAT
    (38) expr -> . INT
    (39) expr -> . ( expr )
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ! expr
    (46) expr -> . + expr
    (47) expr -> . - expr
    (48) expr -> . expr | expr
    (49) expr -> . expr ^ expr
    (50) expr -> . expr & expr
    (51) expr -> . expr GREATER expr
    (52) expr -> . expr LESS expr
    (53) expr -> . expr OR expr
    (54) expr -> . expr AND expr
    (55) expr -> . expr GREATEREQ expr
    (56) expr -> . expr LESSEQ expr
    (57) expr -> . expr NOTEQ expr
    (58) expr -> . expr EQEQ expr
    (59) expr -> . ID ( args )
    (60) expr -> . expr ? expr : expr
    (61) var -> . ID
    FALSE           shift and go to state 15
    TRUE            shift and go to state 16
    STRING          shift and go to state 17
    FLOAT           shift and go to state 18
    INT             shift and go to state 19
    (               shift and go to state 20
    !               shift and go to state 23
    +               shift and go to state 22
    -               shift and go to state 21
    ID              shift and go to state 24

    expr                           shift and go to state 81
    var                            shift and go to state 62

state 41

    (50) expr -> expr & . expr
    (33) expr -> . var
    (34) expr -> . FALSE
    (35) expr -> . TRUE
    (36) expr -> . STRING
    (37) expr -> . FLOAT
    (38) expr -> . INT
    (39) expr -> . ( expr )
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ! expr
    (46) expr -> . + expr
    (47) expr -> . - expr
    (48) expr -> . expr | expr
    (49) expr -> . expr ^ expr
    (50) expr -> . expr & expr
    (51) expr -> . expr GREATER expr
    (52) expr -> . expr LESS expr
    (53) expr -> . expr OR expr
    (54) expr -> . expr AND expr
    (55) expr -> . expr GREATEREQ expr
    (56) expr -> . expr LESSEQ expr
    (57) expr -> . expr NOTEQ expr
    (58) expr -> . expr EQEQ expr
    (59) expr -> . ID ( args )
    (60) expr -> . expr ? expr : expr
    (61) var -> . ID
    FALSE           shift and go to state 15
    TRUE            shift and go to state 16
    STRING          shift and go to state 17
    FLOAT           shift and go to state 18
    INT             shift and go to state 19
    (               shift and go to state 20
    !               shift and go to state 23
    +               shift and go to state 22
    -               shift and go to state 21
    ID              shift and go to state 24

    expr                           shift and go to state 82
    var                            shift and go to state 62

state 42

    (51) expr -> expr GREATER . expr
    (33) expr -> . var
    (34) expr -> . FALSE
    (35) expr -> . TRUE
    (36) expr -> . STRING
    (37) expr -> . FLOAT
    (38) expr -> . INT
    (39) expr -> . ( expr )
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ! expr
    (46) expr -> . + expr
    (47) expr -> . - expr
    (48) expr -> . expr | expr
    (49) expr -> . expr ^ expr
    (50) expr -> . expr & expr
    (51) expr -> . expr GREATER expr
    (52) expr -> . expr LESS expr
    (53) expr -> . expr OR expr
    (54) expr -> . expr AND expr
    (55) expr -> . expr GREATEREQ expr
    (56) expr -> . expr LESSEQ expr
    (57) expr -> . expr NOTEQ expr
    (58) expr -> . expr EQEQ expr
    (59) expr -> . ID ( args )
    (60) expr -> . expr ? expr : expr
    (61) var -> . ID
    FALSE           shift and go to state 15
    TRUE            shift and go to state 16
    STRING          shift and go to state 17
    FLOAT           shift and go to state 18
    INT             shift and go to state 19
    (               shift and go to state 20
    !               shift and go to state 23
    +               shift and go to state 22
    -               shift and go to state 21
    ID              shift and go to state 24

    expr                           shift and go to state 83
    var                            shift and go to state 62

state 43

    (52) expr -> expr LESS . expr
    (33) expr -> . var
    (34) expr -> . FALSE
    (35) expr -> . TRUE
    (36) expr -> . STRING
    (37) expr -> . FLOAT
    (38) expr -> . INT
    (39) expr -> . ( expr )
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ! expr
    (46) expr -> . + expr
    (47) expr -> . - expr
    (48) expr -> . expr | expr
    (49) expr -> . expr ^ expr
    (50) expr -> . expr & expr
    (51) expr -> . expr GREATER expr
    (52) expr -> . expr LESS expr
    (53) expr -> . expr OR expr
    (54) expr -> . expr AND expr
    (55) expr -> . expr GREATEREQ expr
    (56) expr -> . expr LESSEQ expr
    (57) expr -> . expr NOTEQ expr
    (58) expr -> . expr EQEQ expr
    (59) expr -> . ID ( args )
    (60) expr -> . expr ? expr : expr
    (61) var -> . ID
    FALSE           shift and go to state 15
    TRUE            shift and go to state 16
    STRING          shift and go to state 17
    FLOAT           shift and go to state 18
    INT             shift and go to state 19
    (               shift and go to state 20
    !               shift and go to state 23
    +               shift and go to state 22
    -               shift and go to state 21
    ID              shift and go to state 24

    expr                           shift and go to state 84
    var                            shift and go to state 62

state 44

    (53) expr -> expr OR . expr
    (33) expr -> . var
    (34) expr -> . FALSE
    (35) expr -> . TRUE
    (36) expr -> . STRING
    (37) expr -> . FLOAT
    (38) expr -> . INT
    (39) expr -> . ( expr )
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ! expr
    (46) expr -> . + expr
    (47) expr -> . - expr
    (48) expr -> . expr | expr
    (49) expr -> . expr ^ expr
    (50) expr -> . expr & expr
    (51) expr -> . expr GREATER expr
    (52) expr -> . expr LESS expr
    (53) expr -> . expr OR expr
    (54) expr -> . expr AND expr
    (55) expr -> . expr GREATEREQ expr
    (56) expr -> . expr LESSEQ expr
    (57) expr -> . expr NOTEQ expr
    (58) expr -> . expr EQEQ expr
    (59) expr -> . ID ( args )
    (60) expr -> . expr ? expr : expr
    (61) var -> . ID
    FALSE           shift and go to state 15
    TRUE            shift and go to state 16
    STRING          shift and go to state 17
    FLOAT           shift and go to state 18
    INT             shift and go to state 19
    (               shift and go to state 20
    !               shift and go to state 23
    +               shift and go to state 22
    -               shift and go to state 21
    ID              shift and go to state 24

    expr                           shift and go to state 85
    var                            shift and go to state 62

state 45

    (54) expr -> expr AND . expr
    (33) expr -> . var
    (34) expr -> . FALSE
    (35) expr -> . TRUE
    (36) expr -> . STRING
    (37) expr -> . FLOAT
    (38) expr -> . INT
    (39) expr -> . ( expr )
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ! expr
    (46) expr -> . + expr
    (47) expr -> . - expr
    (48) expr -> . expr | expr
    (49) expr -> . expr ^ expr
    (50) expr -> . expr & expr
    (51) expr -> . expr GREATER expr
    (52) expr -> . expr LESS expr
    (53) expr -> . expr OR expr
    (54) expr -> . expr AND expr
    (55) expr -> . expr GREATEREQ expr
    (56) expr -> . expr LESSEQ expr
    (57) expr -> . expr NOTEQ expr
    (58) expr -> . expr EQEQ expr
    (59) expr -> . ID ( args )
    (60) expr -> . expr ? expr : expr
    (61) var -> . ID
    FALSE           shift and go to state 15
    TRUE            shift and go to state 16
    STRING          shift and go to state 17
    FLOAT           shift and go to state 18
    INT             shift and go to state 19
    (               shift and go to state 20
    !               shift and go to state 23
    +               shift and go to state 22
    -               shift and go to state 21
    ID              shift and go to state 24

    expr                           shift and go to state 86
    var                            shift and go to state 62

state 46

    (55) expr -> expr GREATEREQ . expr
    (33) expr -> . var
    (34) expr -> . FALSE
    (35) expr -> . TRUE
    (36) expr -> . STRING
    (37) expr -> . FLOAT
    (38) expr -> . INT
    (39) expr -> . ( expr )
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ! expr
    (46) expr -> . + expr
    (47) expr -> . - expr
    (48) expr -> . expr | expr
    (49) expr -> . expr ^ expr
    (50) expr -> . expr & expr
    (51) expr -> . expr GREATER expr
    (52) expr -> . expr LESS expr
    (53) expr -> . expr OR expr
    (54) expr -> . expr AND expr
    (55) expr -> . expr GREATEREQ expr
    (56) expr -> . expr LESSEQ expr
    (57) expr -> . expr NOTEQ expr
    (58) expr -> . expr EQEQ expr
    (59) expr -> . ID ( args )
    (60) expr -> . expr ? expr : expr
    (61) var -> . ID
    FALSE           shift and go to state 15
    TRUE            shift and go to state 16
    STRING          shift and go to state 17
    FLOAT           shift and go to state 18
    INT             shift and go to state 19
    (               shift and go to state 20
    !               shift and go to state 23
    +               shift and go to state 22
    -               shift and go to state 21
    ID              shift and go to state 24

    expr                           shift and go to state 87
    var                            shift and go to state 62

state 47

    (56) expr -> expr LESSEQ . expr
    (33) expr -> . var
    (34) expr -> . FALSE
    (35) expr -> . TRUE
    (36) expr -> . STRING
    (37) expr -> . FLOAT
    (38) expr -> . INT
    (39) expr -> . ( expr )
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ! expr
    (46) expr -> . + expr
    (47) expr -> . - expr
    (48) expr -> . expr | expr
    (49) expr -> . expr ^ expr
    (50) expr -> . expr & expr
    (51) expr -> . expr GREATER expr
    (52) expr -> . expr LESS expr
    (53) expr -> . expr OR expr
    (54) expr -> . expr AND expr
    (55) expr -> . expr GREATEREQ expr
    (56) expr -> . expr LESSEQ expr
    (57) expr -> . expr NOTEQ expr
    (58) expr -> . expr EQEQ expr
    (59) expr -> . ID ( args )
    (60) expr -> . expr ? expr : expr
    (61) var -> . ID
    FALSE           shift and go to state 15
    TRUE            shift and go to state 16
    STRING          shift and go to state 17
    FLOAT           shift and go to state 18
    INT             shift and go to state 19
    (               shift and go to state 20
    !               shift and go to state 23
    +               shift and go to state 22
    -               shift and go to state 21
    ID              shift and go to state 24

    expr                           shift and go to state 88
    var                            shift and go to state 62

state 48

    (57) expr -> expr NOTEQ . expr
    (33) expr -> . var
    (34) expr -> . FALSE
    (35) expr -> . TRUE
    (36) expr -> . STRING
    (37) expr -> . FLOAT
    (38) expr -> . INT
    (39) expr -> . ( expr )
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ! expr
    (46) expr -> . + expr
    (47) expr -> . - expr
    (48) expr -> . expr | expr
    (49) expr -> . expr ^ expr
    (50) expr -> . expr & expr
    (51) expr -> . expr GREATER expr
    (52) expr -> . expr LESS expr
    (53) expr -> . expr OR expr
    (54) expr -> . expr AND expr
    (55) expr -> . expr GREATEREQ expr
    (56) expr -> . expr LESSEQ expr
    (57) expr -> . expr NOTEQ expr
    (58) expr -> . expr EQEQ expr
    (59) expr -> . ID ( args )
    (60) expr -> . expr ? expr : expr
    (61) var -> . ID
    FALSE           shift and go to state 15
    TRUE            shift and go to state 16
    STRING          shift and go to state 17
    FLOAT           shift and go to state 18
    INT             shift and go to state 19
    (               shift and go to state 20
    !               shift and go to state 23
    +               shift and go to state 22
    -               shift and go to state 21
    ID              shift and go to state 24

    expr                           shift and go to state 89
    var                            shift and go to state 62

state 49

    (58) expr -> expr EQEQ . expr
    (33) expr -> . var
    (34) expr -> . FALSE
    (35) expr -> . TRUE
    (36) expr -> . STRING
    (37) expr -> . FLOAT
    (38) expr -> . INT
    (39) expr -> . ( expr )
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ! expr
    (46) expr -> . + expr
    (47) expr -> . - expr
    (48) expr -> . expr | expr
    (49) expr -> . expr ^ expr
    (50) expr -> . expr & expr
    (51) expr -> . expr GREATER expr
    (52) expr -> . expr LESS expr
    (53) expr -> . expr OR expr
    (54) expr -> . expr AND expr
    (55) expr -> . expr GREATEREQ expr
    (56) expr -> . expr LESSEQ expr
    (57) expr -> . expr NOTEQ expr
    (58) expr -> . expr EQEQ expr
    (59) expr -> . ID ( args )
    (60) expr -> . expr ? expr : expr
    (61) var -> . ID
    FALSE           shift and go to state 15
    TRUE            shift and go to state 16
    STRING          shift and go to state 17
    FLOAT           shift and go to state 18
    INT             shift and go to state 19
    (               shift and go to state 20
    !               shift and go to state 23
    +               shift and go to state 22
    -               shift and go to state 21
    ID              shift and go to state 24

    expr                           shift and go to state 90
    var                            shift and go to state 62

state 50

    (60) expr -> expr ? . expr : expr
    (33) expr -> . var
    (34) expr -> . FALSE
    (35) expr -> . TRUE
    (36) expr -> . STRING
    (37) expr -> . FLOAT
    (38) expr -> . INT
    (39) expr -> . ( expr )
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ! expr
    (46) expr -> . + expr
    (47) expr -> . - expr
    (48) expr -> . expr | expr
    (49) expr -> . expr ^ expr
    (50) expr -> . expr & expr
    (51) expr -> . expr GREATER expr
    (52) expr -> . expr LESS expr
    (53) expr -> . expr OR expr
    (54) expr -> . expr AND expr
    (55) expr -> . expr GREATEREQ expr
    (56) expr -> . expr LESSEQ expr
    (57) expr -> . expr NOTEQ expr
    (58) expr -> . expr EQEQ expr
    (59) expr -> . ID ( args )
    (60) expr -> . expr ? expr : expr
    (61) var -> . ID
    FALSE           shift and go to state 15
    TRUE            shift and go to state 16
    STRING          shift and go to state 17
    FLOAT           shift and go to state 18
    INT             shift and go to state 19
    (               shift and go to state 20
    !               shift and go to state 23
    +               shift and go to state 22
    -               shift and go to state 21
    ID              shift and go to state 24

    expr                           shift and go to state 91
    var                            shift and go to state 62

state 51

    (6) statement -> var_assign SEP .
    LET             reduce using rule 6 (statement -> var_assign SEP .)
    FALSE           reduce using rule 6 (statement -> var_assign SEP .)
    TRUE            reduce using rule 6 (statement -> var_assign SEP .)
    STRING          reduce using rule 6 (statement -> var_assign SEP .)
    FLOAT           reduce using rule 6 (statement -> var_assign SEP .)
    INT             reduce using rule 6 (statement -> var_assign SEP .)
    (               reduce using rule 6 (statement -> var_assign SEP .)
    !               reduce using rule 6 (statement -> var_assign SEP .)
    +               reduce using rule 6 (statement -> var_assign SEP .)
    -               reduce using rule 6 (statement -> var_assign SEP .)
    ID              reduce using rule 6 (statement -> var_assign SEP .)
    DEC             reduce using rule 6 (statement -> var_assign SEP .)
    INC             reduce using rule 6 (statement -> var_assign SEP .)
    IF              reduce using rule 6 (statement -> var_assign SEP .)
    FOR             reduce using rule 6 (statement -> var_assign SEP .)
    WHILE           reduce using rule 6 (statement -> var_assign SEP .)
    RETURN          reduce using rule 6 (statement -> var_assign SEP .)
    FN              reduce using rule 6 (statement -> var_assign SEP .)
    $end            reduce using rule 6 (statement -> var_assign SEP .)
    }               reduce using rule 6 (statement -> var_assign SEP .)
    ELSE            reduce using rule 6 (statement -> var_assign SEP .)


state 52

    (7) statement -> LET var . : var_type SEP
    (19) var_define -> LET var . ASSIGN expr
    :               shift and go to state 92
    ASSIGN          shift and go to state 93


state 53

    (61) var -> ID .
    :               reduce using rule 61 (var -> ID .)
    ASSIGN          reduce using rule 61 (var -> ID .)
    SEP             reduce using rule 61 (var -> ID .)
    {               reduce using rule 61 (var -> ID .)
    LET             reduce using rule 61 (var -> ID .)
    FALSE           reduce using rule 61 (var -> ID .)
    TRUE            reduce using rule 61 (var -> ID .)
    STRING          reduce using rule 61 (var -> ID .)
    FLOAT           reduce using rule 61 (var -> ID .)
    INT             reduce using rule 61 (var -> ID .)
    (               reduce using rule 61 (var -> ID .)
    !               reduce using rule 61 (var -> ID .)
    +               reduce using rule 61 (var -> ID .)
    -               reduce using rule 61 (var -> ID .)
    ID              reduce using rule 61 (var -> ID .)
    DEC             reduce using rule 61 (var -> ID .)
    INC             reduce using rule 61 (var -> ID .)
    IF              reduce using rule 61 (var -> ID .)
    FOR             reduce using rule 61 (var -> ID .)
    WHILE           reduce using rule 61 (var -> ID .)
    RETURN          reduce using rule 61 (var -> ID .)
    FN              reduce using rule 61 (var -> ID .)
    MODULOASGN      reduce using rule 61 (var -> ID .)
    SLASHASGN       reduce using rule 61 (var -> ID .)
    STARASGN        reduce using rule 61 (var -> ID .)
    MINUSASGN       reduce using rule 61 (var -> ID .)
    PLUSASGN        reduce using rule 61 (var -> ID .)


state 54

    (23) var_assign -> var MODULOASGN . expr
    (33) expr -> . var
    (34) expr -> . FALSE
    (35) expr -> . TRUE
    (36) expr -> . STRING
    (37) expr -> . FLOAT
    (38) expr -> . INT
    (39) expr -> . ( expr )
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ! expr
    (46) expr -> . + expr
    (47) expr -> . - expr
    (48) expr -> . expr | expr
    (49) expr -> . expr ^ expr
    (50) expr -> . expr & expr
    (51) expr -> . expr GREATER expr
    (52) expr -> . expr LESS expr
    (53) expr -> . expr OR expr
    (54) expr -> . expr AND expr
    (55) expr -> . expr GREATEREQ expr
    (56) expr -> . expr LESSEQ expr
    (57) expr -> . expr NOTEQ expr
    (58) expr -> . expr EQEQ expr
    (59) expr -> . ID ( args )
    (60) expr -> . expr ? expr : expr
    (61) var -> . ID
    FALSE           shift and go to state 15
    TRUE            shift and go to state 16
    STRING          shift and go to state 17
    FLOAT           shift and go to state 18
    INT             shift and go to state 19
    (               shift and go to state 20
    !               shift and go to state 23
    +               shift and go to state 22
    -               shift and go to state 21
    ID              shift and go to state 24

    var                            shift and go to state 62
    expr                           shift and go to state 94

state 55

    (24) var_assign -> var SLASHASGN . expr
    (33) expr -> . var
    (34) expr -> . FALSE
    (35) expr -> . TRUE
    (36) expr -> . STRING
    (37) expr -> . FLOAT
    (38) expr -> . INT
    (39) expr -> . ( expr )
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ! expr
    (46) expr -> . + expr
    (47) expr -> . - expr
    (48) expr -> . expr | expr
    (49) expr -> . expr ^ expr
    (50) expr -> . expr & expr
    (51) expr -> . expr GREATER expr
    (52) expr -> . expr LESS expr
    (53) expr -> . expr OR expr
    (54) expr -> . expr AND expr
    (55) expr -> . expr GREATEREQ expr
    (56) expr -> . expr LESSEQ expr
    (57) expr -> . expr NOTEQ expr
    (58) expr -> . expr EQEQ expr
    (59) expr -> . ID ( args )
    (60) expr -> . expr ? expr : expr
    (61) var -> . ID
    FALSE           shift and go to state 15
    TRUE            shift and go to state 16
    STRING          shift and go to state 17
    FLOAT           shift and go to state 18
    INT             shift and go to state 19
    (               shift and go to state 20
    !               shift and go to state 23
    +               shift and go to state 22
    -               shift and go to state 21
    ID              shift and go to state 24

    var                            shift and go to state 62
    expr                           shift and go to state 95

state 56

    (25) var_assign -> var STARASGN . expr
    (33) expr -> . var
    (34) expr -> . FALSE
    (35) expr -> . TRUE
    (36) expr -> . STRING
    (37) expr -> . FLOAT
    (38) expr -> . INT
    (39) expr -> . ( expr )
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ! expr
    (46) expr -> . + expr
    (47) expr -> . - expr
    (48) expr -> . expr | expr
    (49) expr -> . expr ^ expr
    (50) expr -> . expr & expr
    (51) expr -> . expr GREATER expr
    (52) expr -> . expr LESS expr
    (53) expr -> . expr OR expr
    (54) expr -> . expr AND expr
    (55) expr -> . expr GREATEREQ expr
    (56) expr -> . expr LESSEQ expr
    (57) expr -> . expr NOTEQ expr
    (58) expr -> . expr EQEQ expr
    (59) expr -> . ID ( args )
    (60) expr -> . expr ? expr : expr
    (61) var -> . ID
    FALSE           shift and go to state 15
    TRUE            shift and go to state 16
    STRING          shift and go to state 17
    FLOAT           shift and go to state 18
    INT             shift and go to state 19
    (               shift and go to state 20
    !               shift and go to state 23
    +               shift and go to state 22
    -               shift and go to state 21
    ID              shift and go to state 24

    var                            shift and go to state 62
    expr                           shift and go to state 96

state 57

    (26) var_assign -> var MINUSASGN . expr
    (33) expr -> . var
    (34) expr -> . FALSE
    (35) expr -> . TRUE
    (36) expr -> . STRING
    (37) expr -> . FLOAT
    (38) expr -> . INT
    (39) expr -> . ( expr )
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ! expr
    (46) expr -> . + expr
    (47) expr -> . - expr
    (48) expr -> . expr | expr
    (49) expr -> . expr ^ expr
    (50) expr -> . expr & expr
    (51) expr -> . expr GREATER expr
    (52) expr -> . expr LESS expr
    (53) expr -> . expr OR expr
    (54) expr -> . expr AND expr
    (55) expr -> . expr GREATEREQ expr
    (56) expr -> . expr LESSEQ expr
    (57) expr -> . expr NOTEQ expr
    (58) expr -> . expr EQEQ expr
    (59) expr -> . ID ( args )
    (60) expr -> . expr ? expr : expr
    (61) var -> . ID
    FALSE           shift and go to state 15
    TRUE            shift and go to state 16
    STRING          shift and go to state 17
    FLOAT           shift and go to state 18
    INT             shift and go to state 19
    (               shift and go to state 20
    !               shift and go to state 23
    +               shift and go to state 22
    -               shift and go to state 21
    ID              shift and go to state 24

    var                            shift and go to state 62
    expr                           shift and go to state 97

state 58

    (27) var_assign -> var PLUSASGN . expr
    (33) expr -> . var
    (34) expr -> . FALSE
    (35) expr -> . TRUE
    (36) expr -> . STRING
    (37) expr -> . FLOAT
    (38) expr -> . INT
    (39) expr -> . ( expr )
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ! expr
    (46) expr -> . + expr
    (47) expr -> . - expr
    (48) expr -> . expr | expr
    (49) expr -> . expr ^ expr
    (50) expr -> . expr & expr
    (51) expr -> . expr GREATER expr
    (52) expr -> . expr LESS expr
    (53) expr -> . expr OR expr
    (54) expr -> . expr AND expr
    (55) expr -> . expr GREATEREQ expr
    (56) expr -> . expr LESSEQ expr
    (57) expr -> . expr NOTEQ expr
    (58) expr -> . expr EQEQ expr
    (59) expr -> . ID ( args )
    (60) expr -> . expr ? expr : expr
    (61) var -> . ID
    FALSE           shift and go to state 15
    TRUE            shift and go to state 16
    STRING          shift and go to state 17
    FLOAT           shift and go to state 18
    INT             shift and go to state 19
    (               shift and go to state 20
    !               shift and go to state 23
    +               shift and go to state 22
    -               shift and go to state 21
    ID              shift and go to state 24

    var                            shift and go to state 62
    expr                           shift and go to state 98

state 59

    (28) var_assign -> var ASSIGN . expr
    (33) expr -> . var
    (34) expr -> . FALSE
    (35) expr -> . TRUE
    (36) expr -> . STRING
    (37) expr -> . FLOAT
    (38) expr -> . INT
    (39) expr -> . ( expr )
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ! expr
    (46) expr -> . + expr
    (47) expr -> . - expr
    (48) expr -> . expr | expr
    (49) expr -> . expr ^ expr
    (50) expr -> . expr & expr
    (51) expr -> . expr GREATER expr
    (52) expr -> . expr LESS expr
    (53) expr -> . expr OR expr
    (54) expr -> . expr AND expr
    (55) expr -> . expr GREATEREQ expr
    (56) expr -> . expr LESSEQ expr
    (57) expr -> . expr NOTEQ expr
    (58) expr -> . expr EQEQ expr
    (59) expr -> . ID ( args )
    (60) expr -> . expr ? expr : expr
    (61) var -> . ID
    FALSE           shift and go to state 15
    TRUE            shift and go to state 16
    STRING          shift and go to state 17
    FLOAT           shift and go to state 18
    INT             shift and go to state 19
    (               shift and go to state 20
    !               shift and go to state 23
    +               shift and go to state 22
    -               shift and go to state 21
    ID              shift and go to state 24

    var                            shift and go to state 62
    expr                           shift and go to state 99

state 60

    (8) statement -> var_define SEP .
    LET             reduce using rule 8 (statement -> var_define SEP .)
    FALSE           reduce using rule 8 (statement -> var_define SEP .)
    TRUE            reduce using rule 8 (statement -> var_define SEP .)
    STRING          reduce using rule 8 (statement -> var_define SEP .)
    FLOAT           reduce using rule 8 (statement -> var_define SEP .)
    INT             reduce using rule 8 (statement -> var_define SEP .)
    (               reduce using rule 8 (statement -> var_define SEP .)
    !               reduce using rule 8 (statement -> var_define SEP .)
    +               reduce using rule 8 (statement -> var_define SEP .)
    -               reduce using rule 8 (statement -> var_define SEP .)
    ID              reduce using rule 8 (statement -> var_define SEP .)
    DEC             reduce using rule 8 (statement -> var_define SEP .)
    INC             reduce using rule 8 (statement -> var_define SEP .)
    IF              reduce using rule 8 (statement -> var_define SEP .)
    FOR             reduce using rule 8 (statement -> var_define SEP .)
    WHILE           reduce using rule 8 (statement -> var_define SEP .)
    RETURN          reduce using rule 8 (statement -> var_define SEP .)
    FN              reduce using rule 8 (statement -> var_define SEP .)
    $end            reduce using rule 8 (statement -> var_define SEP .)
    }               reduce using rule 8 (statement -> var_define SEP .)
    ELSE            reduce using rule 8 (statement -> var_define SEP .)


state 61

    (39) expr -> ( expr . )
    (40) expr -> expr . % expr
    (41) expr -> expr . / expr
    (42) expr -> expr . * expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    (48) expr -> expr . | expr
    (49) expr -> expr . ^ expr
    (50) expr -> expr . & expr
    (51) expr -> expr . GREATER expr
    (52) expr -> expr . LESS expr
    (53) expr -> expr . OR expr
    (54) expr -> expr . AND expr
    (55) expr -> expr . GREATEREQ expr
    (56) expr -> expr . LESSEQ expr
    (57) expr -> expr . NOTEQ expr
    (58) expr -> expr . EQEQ expr
    (60) expr -> expr . ? expr : expr
    )               shift and go to state 100
    %               shift and go to state 34
    /               shift and go to state 35
    *               shift and go to state 36
    -               shift and go to state 37
    +               shift and go to state 38
    |               shift and go to state 39
    ^               shift and go to state 40
    &               shift and go to state 41
    GREATER         shift and go to state 42
    LESS            shift and go to state 43
    OR              shift and go to state 44
    AND             shift and go to state 45
    GREATEREQ       shift and go to state 46
    LESSEQ          shift and go to state 47
    NOTEQ           shift and go to state 48
    EQEQ            shift and go to state 49
    ?               shift and go to state 50


state 62

    (33) expr -> var .
    )               reduce using rule 33 (expr -> var .)
    %               reduce using rule 33 (expr -> var .)
    /               reduce using rule 33 (expr -> var .)
    *               reduce using rule 33 (expr -> var .)
    -               reduce using rule 33 (expr -> var .)
    +               reduce using rule 33 (expr -> var .)
    |               reduce using rule 33 (expr -> var .)
    ^               reduce using rule 33 (expr -> var .)
    &               reduce using rule 33 (expr -> var .)
    GREATER         reduce using rule 33 (expr -> var .)
    LESS            reduce using rule 33 (expr -> var .)
    OR              reduce using rule 33 (expr -> var .)
    AND             reduce using rule 33 (expr -> var .)
    GREATEREQ       reduce using rule 33 (expr -> var .)
    LESSEQ          reduce using rule 33 (expr -> var .)
    NOTEQ           reduce using rule 33 (expr -> var .)
    EQEQ            reduce using rule 33 (expr -> var .)
    ?               reduce using rule 33 (expr -> var .)
    SEP             reduce using rule 33 (expr -> var .)
    {               reduce using rule 33 (expr -> var .)
    LET             reduce using rule 33 (expr -> var .)
    FALSE           reduce using rule 33 (expr -> var .)
    TRUE            reduce using rule 33 (expr -> var .)
    STRING          reduce using rule 33 (expr -> var .)
    FLOAT           reduce using rule 33 (expr -> var .)
    INT             reduce using rule 33 (expr -> var .)
    (               reduce using rule 33 (expr -> var .)
    !               reduce using rule 33 (expr -> var .)
    ID              reduce using rule 33 (expr -> var .)
    DEC             reduce using rule 33 (expr -> var .)
    INC             reduce using rule 33 (expr -> var .)
    IF              reduce using rule 33 (expr -> var .)
    FOR             reduce using rule 33 (expr -> var .)
    WHILE           reduce using rule 33 (expr -> var .)
    RETURN          reduce using rule 33 (expr -> var .)
    FN              reduce using rule 33 (expr -> var .)
    :               reduce using rule 33 (expr -> var .)
    ,               reduce using rule 33 (expr -> var .)


state 63

    (47) expr -> - expr .
    (40) expr -> expr . % expr
    (41) expr -> expr . / expr
    (42) expr -> expr . * expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    (48) expr -> expr . | expr
    (49) expr -> expr . ^ expr
    (50) expr -> expr . & expr
    (51) expr -> expr . GREATER expr
    (52) expr -> expr . LESS expr
    (53) expr -> expr . OR expr
    (54) expr -> expr . AND expr
    (55) expr -> expr . GREATEREQ expr
    (56) expr -> expr . LESSEQ expr
    (57) expr -> expr . NOTEQ expr
    (58) expr -> expr . EQEQ expr
    (60) expr -> expr . ? expr : expr
    SEP             reduce using rule 47 (expr -> - expr .)
    %               reduce using rule 47 (expr -> - expr .)
    /               reduce using rule 47 (expr -> - expr .)
    *               reduce using rule 47 (expr -> - expr .)
    -               reduce using rule 47 (expr -> - expr .)
    +               reduce using rule 47 (expr -> - expr .)
    |               reduce using rule 47 (expr -> - expr .)
    ^               reduce using rule 47 (expr -> - expr .)
    &               reduce using rule 47 (expr -> - expr .)
    GREATER         reduce using rule 47 (expr -> - expr .)
    LESS            reduce using rule 47 (expr -> - expr .)
    OR              reduce using rule 47 (expr -> - expr .)
    AND             reduce using rule 47 (expr -> - expr .)
    GREATEREQ       reduce using rule 47 (expr -> - expr .)
    LESSEQ          reduce using rule 47 (expr -> - expr .)
    NOTEQ           reduce using rule 47 (expr -> - expr .)
    EQEQ            reduce using rule 47 (expr -> - expr .)
    ?               reduce using rule 47 (expr -> - expr .)
    )               reduce using rule 47 (expr -> - expr .)
    {               reduce using rule 47 (expr -> - expr .)
    LET             reduce using rule 47 (expr -> - expr .)
    FALSE           reduce using rule 47 (expr -> - expr .)
    TRUE            reduce using rule 47 (expr -> - expr .)
    STRING          reduce using rule 47 (expr -> - expr .)
    FLOAT           reduce using rule 47 (expr -> - expr .)
    INT             reduce using rule 47 (expr -> - expr .)
    (               reduce using rule 47 (expr -> - expr .)
    !               reduce using rule 47 (expr -> - expr .)
    ID              reduce using rule 47 (expr -> - expr .)
    DEC             reduce using rule 47 (expr -> - expr .)
    INC             reduce using rule 47 (expr -> - expr .)
    IF              reduce using rule 47 (expr -> - expr .)
    FOR             reduce using rule 47 (expr -> - expr .)
    WHILE           reduce using rule 47 (expr -> - expr .)
    RETURN          reduce using rule 47 (expr -> - expr .)
    FN              reduce using rule 47 (expr -> - expr .)
    :               reduce using rule 47 (expr -> - expr .)
    ,               reduce using rule 47 (expr -> - expr .)


state 64

    (46) expr -> + expr .
    (40) expr -> expr . % expr
    (41) expr -> expr . / expr
    (42) expr -> expr . * expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    (48) expr -> expr . | expr
    (49) expr -> expr . ^ expr
    (50) expr -> expr . & expr
    (51) expr -> expr . GREATER expr
    (52) expr -> expr . LESS expr
    (53) expr -> expr . OR expr
    (54) expr -> expr . AND expr
    (55) expr -> expr . GREATEREQ expr
    (56) expr -> expr . LESSEQ expr
    (57) expr -> expr . NOTEQ expr
    (58) expr -> expr . EQEQ expr
    (60) expr -> expr . ? expr : expr
    SEP             reduce using rule 46 (expr -> + expr .)
    %               reduce using rule 46 (expr -> + expr .)
    /               reduce using rule 46 (expr -> + expr .)
    *               reduce using rule 46 (expr -> + expr .)
    -               reduce using rule 46 (expr -> + expr .)
    +               reduce using rule 46 (expr -> + expr .)
    |               reduce using rule 46 (expr -> + expr .)
    ^               reduce using rule 46 (expr -> + expr .)
    &               reduce using rule 46 (expr -> + expr .)
    GREATER         reduce using rule 46 (expr -> + expr .)
    LESS            reduce using rule 46 (expr -> + expr .)
    OR              reduce using rule 46 (expr -> + expr .)
    AND             reduce using rule 46 (expr -> + expr .)
    GREATEREQ       reduce using rule 46 (expr -> + expr .)
    LESSEQ          reduce using rule 46 (expr -> + expr .)
    NOTEQ           reduce using rule 46 (expr -> + expr .)
    EQEQ            reduce using rule 46 (expr -> + expr .)
    ?               reduce using rule 46 (expr -> + expr .)
    )               reduce using rule 46 (expr -> + expr .)
    {               reduce using rule 46 (expr -> + expr .)
    LET             reduce using rule 46 (expr -> + expr .)
    FALSE           reduce using rule 46 (expr -> + expr .)
    TRUE            reduce using rule 46 (expr -> + expr .)
    STRING          reduce using rule 46 (expr -> + expr .)
    FLOAT           reduce using rule 46 (expr -> + expr .)
    INT             reduce using rule 46 (expr -> + expr .)
    (               reduce using rule 46 (expr -> + expr .)
    !               reduce using rule 46 (expr -> + expr .)
    ID              reduce using rule 46 (expr -> + expr .)
    DEC             reduce using rule 46 (expr -> + expr .)
    INC             reduce using rule 46 (expr -> + expr .)
    IF              reduce using rule 46 (expr -> + expr .)
    FOR             reduce using rule 46 (expr -> + expr .)
    WHILE           reduce using rule 46 (expr -> + expr .)
    RETURN          reduce using rule 46 (expr -> + expr .)
    FN              reduce using rule 46 (expr -> + expr .)
    :               reduce using rule 46 (expr -> + expr .)
    ,               reduce using rule 46 (expr -> + expr .)


state 65

    (45) expr -> ! expr .
    (40) expr -> expr . % expr
    (41) expr -> expr . / expr
    (42) expr -> expr . * expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    (48) expr -> expr . | expr
    (49) expr -> expr . ^ expr
    (50) expr -> expr . & expr
    (51) expr -> expr . GREATER expr
    (52) expr -> expr . LESS expr
    (53) expr -> expr . OR expr
    (54) expr -> expr . AND expr
    (55) expr -> expr . GREATEREQ expr
    (56) expr -> expr . LESSEQ expr
    (57) expr -> expr . NOTEQ expr
    (58) expr -> expr . EQEQ expr
    (60) expr -> expr . ? expr : expr
    SEP             reduce using rule 45 (expr -> ! expr .)
    %               reduce using rule 45 (expr -> ! expr .)
    /               reduce using rule 45 (expr -> ! expr .)
    *               reduce using rule 45 (expr -> ! expr .)
    -               reduce using rule 45 (expr -> ! expr .)
    +               reduce using rule 45 (expr -> ! expr .)
    |               reduce using rule 45 (expr -> ! expr .)
    ^               reduce using rule 45 (expr -> ! expr .)
    &               reduce using rule 45 (expr -> ! expr .)
    GREATER         reduce using rule 45 (expr -> ! expr .)
    LESS            reduce using rule 45 (expr -> ! expr .)
    OR              reduce using rule 45 (expr -> ! expr .)
    AND             reduce using rule 45 (expr -> ! expr .)
    GREATEREQ       reduce using rule 45 (expr -> ! expr .)
    LESSEQ          reduce using rule 45 (expr -> ! expr .)
    NOTEQ           reduce using rule 45 (expr -> ! expr .)
    EQEQ            reduce using rule 45 (expr -> ! expr .)
    ?               reduce using rule 45 (expr -> ! expr .)
    )               reduce using rule 45 (expr -> ! expr .)
    {               reduce using rule 45 (expr -> ! expr .)
    LET             reduce using rule 45 (expr -> ! expr .)
    FALSE           reduce using rule 45 (expr -> ! expr .)
    TRUE            reduce using rule 45 (expr -> ! expr .)
    STRING          reduce using rule 45 (expr -> ! expr .)
    FLOAT           reduce using rule 45 (expr -> ! expr .)
    INT             reduce using rule 45 (expr -> ! expr .)
    (               reduce using rule 45 (expr -> ! expr .)
    !               reduce using rule 45 (expr -> ! expr .)
    ID              reduce using rule 45 (expr -> ! expr .)
    DEC             reduce using rule 45 (expr -> ! expr .)
    INC             reduce using rule 45 (expr -> ! expr .)
    IF              reduce using rule 45 (expr -> ! expr .)
    FOR             reduce using rule 45 (expr -> ! expr .)
    WHILE           reduce using rule 45 (expr -> ! expr .)
    RETURN          reduce using rule 45 (expr -> ! expr .)
    FN              reduce using rule 45 (expr -> ! expr .)
    :               reduce using rule 45 (expr -> ! expr .)
    ,               reduce using rule 45 (expr -> ! expr .)


state 66

    (59) expr -> ID ( . args )
    (69) args -> . empty
    (70) args -> . arg
    (71) args -> . args , arg
    (62) empty -> .
    (72) arg -> . expr
    (33) expr -> . var
    (34) expr -> . FALSE
    (35) expr -> . TRUE
    (36) expr -> . STRING
    (37) expr -> . FLOAT
    (38) expr -> . INT
    (39) expr -> . ( expr )
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ! expr
    (46) expr -> . + expr
    (47) expr -> . - expr
    (48) expr -> . expr | expr
    (49) expr -> . expr ^ expr
    (50) expr -> . expr & expr
    (51) expr -> . expr GREATER expr
    (52) expr -> . expr LESS expr
    (53) expr -> . expr OR expr
    (54) expr -> . expr AND expr
    (55) expr -> . expr GREATEREQ expr
    (56) expr -> . expr LESSEQ expr
    (57) expr -> . expr NOTEQ expr
    (58) expr -> . expr EQEQ expr
    (59) expr -> . ID ( args )
    (60) expr -> . expr ? expr : expr
    (61) var -> . ID
    )               reduce using rule 62 (empty -> .)
    ,               reduce using rule 62 (empty -> .)
    FALSE           shift and go to state 15
    TRUE            shift and go to state 16
    STRING          shift and go to state 17
    FLOAT           shift and go to state 18
    INT             shift and go to state 19
    (               shift and go to state 20
    !               shift and go to state 23
    +               shift and go to state 22
    -               shift and go to state 21
    ID              shift and go to state 24

    args                           shift and go to state 101
    empty                          shift and go to state 102
    arg                            shift and go to state 103
    expr                           shift and go to state 104
    var                            shift and go to state 62

state 67

    (21) var_assign -> DEC var .
    SEP             reduce using rule 21 (var_assign -> DEC var .)
    {               reduce using rule 21 (var_assign -> DEC var .)
    LET             reduce using rule 21 (var_assign -> DEC var .)
    FALSE           reduce using rule 21 (var_assign -> DEC var .)
    TRUE            reduce using rule 21 (var_assign -> DEC var .)
    STRING          reduce using rule 21 (var_assign -> DEC var .)
    FLOAT           reduce using rule 21 (var_assign -> DEC var .)
    INT             reduce using rule 21 (var_assign -> DEC var .)
    (               reduce using rule 21 (var_assign -> DEC var .)
    !               reduce using rule 21 (var_assign -> DEC var .)
    +               reduce using rule 21 (var_assign -> DEC var .)
    -               reduce using rule 21 (var_assign -> DEC var .)
    ID              reduce using rule 21 (var_assign -> DEC var .)
    DEC             reduce using rule 21 (var_assign -> DEC var .)
    INC             reduce using rule 21 (var_assign -> DEC var .)
    IF              reduce using rule 21 (var_assign -> DEC var .)
    FOR             reduce using rule 21 (var_assign -> DEC var .)
    WHILE           reduce using rule 21 (var_assign -> DEC var .)
    RETURN          reduce using rule 21 (var_assign -> DEC var .)
    FN              reduce using rule 21 (var_assign -> DEC var .)


state 68

    (22) var_assign -> INC var .
    SEP             reduce using rule 22 (var_assign -> INC var .)
    {               reduce using rule 22 (var_assign -> INC var .)
    LET             reduce using rule 22 (var_assign -> INC var .)
    FALSE           reduce using rule 22 (var_assign -> INC var .)
    TRUE            reduce using rule 22 (var_assign -> INC var .)
    STRING          reduce using rule 22 (var_assign -> INC var .)
    FLOAT           reduce using rule 22 (var_assign -> INC var .)
    INT             reduce using rule 22 (var_assign -> INC var .)
    (               reduce using rule 22 (var_assign -> INC var .)
    !               reduce using rule 22 (var_assign -> INC var .)
    +               reduce using rule 22 (var_assign -> INC var .)
    -               reduce using rule 22 (var_assign -> INC var .)
    ID              reduce using rule 22 (var_assign -> INC var .)
    DEC             reduce using rule 22 (var_assign -> INC var .)
    INC             reduce using rule 22 (var_assign -> INC var .)
    IF              reduce using rule 22 (var_assign -> INC var .)
    FOR             reduce using rule 22 (var_assign -> INC var .)
    WHILE           reduce using rule 22 (var_assign -> INC var .)
    RETURN          reduce using rule 22 (var_assign -> INC var .)
    FN              reduce using rule 22 (var_assign -> INC var .)


state 69

    (29) if_statement -> IF expr . block
    (30) if_statement -> IF expr . block ELSE block
    (40) expr -> expr . % expr
    (41) expr -> expr . / expr
    (42) expr -> expr . * expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    (48) expr -> expr . | expr
    (49) expr -> expr . ^ expr
    (50) expr -> expr . & expr
    (51) expr -> expr . GREATER expr
    (52) expr -> expr . LESS expr
    (53) expr -> expr . OR expr
    (54) expr -> expr . AND expr
    (55) expr -> expr . GREATEREQ expr
    (56) expr -> expr . LESSEQ expr
    (57) expr -> expr . NOTEQ expr
    (58) expr -> expr . EQEQ expr
    (60) expr -> expr . ? expr : expr
    (63) block -> . statement
    (64) block -> . { program }
    (5) statement -> . expr SEP
    (6) statement -> . var_assign SEP
    (7) statement -> . LET var : var_type SEP
    (8) statement -> . var_define SEP
    (9) statement -> . if_statement
    (10) statement -> . for_statement
    (11) statement -> . while_statement
    (12) statement -> . return_statement
    (13) statement -> . function_definition
    (33) expr -> . var
    (34) expr -> . FALSE
    (35) expr -> . TRUE
    (36) expr -> . STRING
    (37) expr -> . FLOAT
    (38) expr -> . INT
    (39) expr -> . ( expr )
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ! expr
    (46) expr -> . + expr
    (47) expr -> . - expr
    (48) expr -> . expr | expr
    (49) expr -> . expr ^ expr
    (50) expr -> . expr & expr
    (51) expr -> . expr GREATER expr
    (52) expr -> . expr LESS expr
    (53) expr -> . expr OR expr
    (54) expr -> . expr AND expr
    (55) expr -> . expr GREATEREQ expr
    (56) expr -> . expr LESSEQ expr
    (57) expr -> . expr NOTEQ expr
    (58) expr -> . expr EQEQ expr
    (59) expr -> . ID ( args )
    (60) expr -> . expr ? expr : expr
    (21) var_assign -> . DEC var
    (22) var_assign -> . INC var
    (23) var_assign -> . var MODULOASGN expr
    (24) var_assign -> . var SLASHASGN expr
    (25) var_assign -> . var STARASGN expr
    (26) var_assign -> . var MINUSASGN expr
    (27) var_assign -> . var PLUSASGN expr
    (28) var_assign -> . var ASSIGN expr
    (19) var_define -> . LET var ASSIGN expr
    (29) if_statement -> . IF expr block
    (30) if_statement -> . IF expr block ELSE block
    (32) for_statement -> . FOR var_assign SEP expr SEP var_assign block
    (31) while_statement -> . WHILE expr block
    (20) return_statement -> . RETURN expr SEP
    (18) function_definition -> . FN ID ( params ) block
    (61) var -> . ID
    %               shift and go to state 34
    /               shift and go to state 35
    *               shift and go to state 36
    -               shift and go to state 106
    +               shift and go to state 107
    |               shift and go to state 39
    ^               shift and go to state 40
    &               shift and go to state 41
    GREATER         shift and go to state 42
    LESS            shift and go to state 43
    OR              shift and go to state 44
    AND             shift and go to state 45
    GREATEREQ       shift and go to state 46
    LESSEQ          shift and go to state 47
    NOTEQ           shift and go to state 48
    EQEQ            shift and go to state 49
    ?               shift and go to state 50
    {               shift and go to state 109
    LET             shift and go to state 7
    FALSE           shift and go to state 15
    TRUE            shift and go to state 16
    STRING          shift and go to state 17
    FLOAT           shift and go to state 18
    INT             shift and go to state 19
    (               shift and go to state 20
    !               shift and go to state 23
    ID              shift and go to state 24
    DEC             shift and go to state 25
    INC             shift and go to state 26
    IF              shift and go to state 27
    FOR             shift and go to state 28
    WHILE           shift and go to state 29
    RETURN          shift and go to state 30
    FN              shift and go to state 31

    expr                           shift and go to state 5
    block                          shift and go to state 105
    statement                      shift and go to state 108
    var_assign                     shift and go to state 6
    var                            shift and go to state 8
    var_define                     shift and go to state 9
    if_statement                   shift and go to state 10
    for_statement                  shift and go to state 11
    while_statement                shift and go to state 12
    return_statement               shift and go to state 13
    function_definition            shift and go to state 14

state 70

    (32) for_statement -> FOR var_assign . SEP expr SEP var_assign block
    SEP             shift and go to state 110


state 71

    (23) var_assign -> var . MODULOASGN expr
    (24) var_assign -> var . SLASHASGN expr
    (25) var_assign -> var . STARASGN expr
    (26) var_assign -> var . MINUSASGN expr
    (27) var_assign -> var . PLUSASGN expr
    (28) var_assign -> var . ASSIGN expr
    MODULOASGN      shift and go to state 54
    SLASHASGN       shift and go to state 55
    STARASGN        shift and go to state 56
    MINUSASGN       shift and go to state 57
    PLUSASGN        shift and go to state 58
    ASSIGN          shift and go to state 59


state 72

    (31) while_statement -> WHILE expr . block
    (40) expr -> expr . % expr
    (41) expr -> expr . / expr
    (42) expr -> expr . * expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    (48) expr -> expr . | expr
    (49) expr -> expr . ^ expr
    (50) expr -> expr . & expr
    (51) expr -> expr . GREATER expr
    (52) expr -> expr . LESS expr
    (53) expr -> expr . OR expr
    (54) expr -> expr . AND expr
    (55) expr -> expr . GREATEREQ expr
    (56) expr -> expr . LESSEQ expr
    (57) expr -> expr . NOTEQ expr
    (58) expr -> expr . EQEQ expr
    (60) expr -> expr . ? expr : expr
    (63) block -> . statement
    (64) block -> . { program }
    (5) statement -> . expr SEP
    (6) statement -> . var_assign SEP
    (7) statement -> . LET var : var_type SEP
    (8) statement -> . var_define SEP
    (9) statement -> . if_statement
    (10) statement -> . for_statement
    (11) statement -> . while_statement
    (12) statement -> . return_statement
    (13) statement -> . function_definition
    (33) expr -> . var
    (34) expr -> . FALSE
    (35) expr -> . TRUE
    (36) expr -> . STRING
    (37) expr -> . FLOAT
    (38) expr -> . INT
    (39) expr -> . ( expr )
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ! expr
    (46) expr -> . + expr
    (47) expr -> . - expr
    (48) expr -> . expr | expr
    (49) expr -> . expr ^ expr
    (50) expr -> . expr & expr
    (51) expr -> . expr GREATER expr
    (52) expr -> . expr LESS expr
    (53) expr -> . expr OR expr
    (54) expr -> . expr AND expr
    (55) expr -> . expr GREATEREQ expr
    (56) expr -> . expr LESSEQ expr
    (57) expr -> . expr NOTEQ expr
    (58) expr -> . expr EQEQ expr
    (59) expr -> . ID ( args )
    (60) expr -> . expr ? expr : expr
    (21) var_assign -> . DEC var
    (22) var_assign -> . INC var
    (23) var_assign -> . var MODULOASGN expr
    (24) var_assign -> . var SLASHASGN expr
    (25) var_assign -> . var STARASGN expr
    (26) var_assign -> . var MINUSASGN expr
    (27) var_assign -> . var PLUSASGN expr
    (28) var_assign -> . var ASSIGN expr
    (19) var_define -> . LET var ASSIGN expr
    (29) if_statement -> . IF expr block
    (30) if_statement -> . IF expr block ELSE block
    (32) for_statement -> . FOR var_assign SEP expr SEP var_assign block
    (31) while_statement -> . WHILE expr block
    (20) return_statement -> . RETURN expr SEP
    (18) function_definition -> . FN ID ( params ) block
    (61) var -> . ID
    %               shift and go to state 34
    /               shift and go to state 35
    *               shift and go to state 36
    -               shift and go to state 106
    +               shift and go to state 107
    |               shift and go to state 39
    ^               shift and go to state 40
    &               shift and go to state 41
    GREATER         shift and go to state 42
    LESS            shift and go to state 43
    OR              shift and go to state 44
    AND             shift and go to state 45
    GREATEREQ       shift and go to state 46
    LESSEQ          shift and go to state 47
    NOTEQ           shift and go to state 48
    EQEQ            shift and go to state 49
    ?               shift and go to state 50
    {               shift and go to state 109
    LET             shift and go to state 7
    FALSE           shift and go to state 15
    TRUE            shift and go to state 16
    STRING          shift and go to state 17
    FLOAT           shift and go to state 18
    INT             shift and go to state 19
    (               shift and go to state 20
    !               shift and go to state 23
    ID              shift and go to state 24
    DEC             shift and go to state 25
    INC             shift and go to state 26
    IF              shift and go to state 27
    FOR             shift and go to state 28
    WHILE           shift and go to state 29
    RETURN          shift and go to state 30
    FN              shift and go to state 31

    expr                           shift and go to state 5
    block                          shift and go to state 111
    statement                      shift and go to state 108
    var_assign                     shift and go to state 6
    var                            shift and go to state 8
    var_define                     shift and go to state 9
    if_statement                   shift and go to state 10
    for_statement                  shift and go to state 11
    while_statement                shift and go to state 12
    return_statement               shift and go to state 13
    function_definition            shift and go to state 14

state 73

    (20) return_statement -> RETURN expr . SEP
    (40) expr -> expr . % expr
    (41) expr -> expr . / expr
    (42) expr -> expr . * expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    (48) expr -> expr . | expr
    (49) expr -> expr . ^ expr
    (50) expr -> expr . & expr
    (51) expr -> expr . GREATER expr
    (52) expr -> expr . LESS expr
    (53) expr -> expr . OR expr
    (54) expr -> expr . AND expr
    (55) expr -> expr . GREATEREQ expr
    (56) expr -> expr . LESSEQ expr
    (57) expr -> expr . NOTEQ expr
    (58) expr -> expr . EQEQ expr
    (60) expr -> expr . ? expr : expr
    SEP             shift and go to state 112
    %               shift and go to state 34
    /               shift and go to state 35
    *               shift and go to state 36
    -               shift and go to state 37
    +               shift and go to state 38
    |               shift and go to state 39
    ^               shift and go to state 40
    &               shift and go to state 41
    GREATER         shift and go to state 42
    LESS            shift and go to state 43
    OR              shift and go to state 44
    AND             shift and go to state 45
    GREATEREQ       shift and go to state 46
    LESSEQ          shift and go to state 47
    NOTEQ           shift and go to state 48
    EQEQ            shift and go to state 49
    ?               shift and go to state 50


state 74

    (18) function_definition -> FN ID . ( params ) block
    (               shift and go to state 113


state 75

    (40) expr -> expr % expr .
    (40) expr -> expr . % expr
    (41) expr -> expr . / expr
    (42) expr -> expr . * expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    (48) expr -> expr . | expr
    (49) expr -> expr . ^ expr
    (50) expr -> expr . & expr
    (51) expr -> expr . GREATER expr
    (52) expr -> expr . LESS expr
    (53) expr -> expr . OR expr
    (54) expr -> expr . AND expr
    (55) expr -> expr . GREATEREQ expr
    (56) expr -> expr . LESSEQ expr
    (57) expr -> expr . NOTEQ expr
    (58) expr -> expr . EQEQ expr
    (60) expr -> expr . ? expr : expr
    SEP             reduce using rule 40 (expr -> expr % expr .)
    %               reduce using rule 40 (expr -> expr % expr .)
    /               reduce using rule 40 (expr -> expr % expr .)
    *               reduce using rule 40 (expr -> expr % expr .)
    -               reduce using rule 40 (expr -> expr % expr .)
    +               reduce using rule 40 (expr -> expr % expr .)
    |               reduce using rule 40 (expr -> expr % expr .)
    ^               reduce using rule 40 (expr -> expr % expr .)
    &               reduce using rule 40 (expr -> expr % expr .)
    GREATER         reduce using rule 40 (expr -> expr % expr .)
    LESS            reduce using rule 40 (expr -> expr % expr .)
    OR              reduce using rule 40 (expr -> expr % expr .)
    AND             reduce using rule 40 (expr -> expr % expr .)
    GREATEREQ       reduce using rule 40 (expr -> expr % expr .)
    LESSEQ          reduce using rule 40 (expr -> expr % expr .)
    NOTEQ           reduce using rule 40 (expr -> expr % expr .)
    EQEQ            reduce using rule 40 (expr -> expr % expr .)
    ?               reduce using rule 40 (expr -> expr % expr .)
    )               reduce using rule 40 (expr -> expr % expr .)
    {               reduce using rule 40 (expr -> expr % expr .)
    LET             reduce using rule 40 (expr -> expr % expr .)
    FALSE           reduce using rule 40 (expr -> expr % expr .)
    TRUE            reduce using rule 40 (expr -> expr % expr .)
    STRING          reduce using rule 40 (expr -> expr % expr .)
    FLOAT           reduce using rule 40 (expr -> expr % expr .)
    INT             reduce using rule 40 (expr -> expr % expr .)
    (               reduce using rule 40 (expr -> expr % expr .)
    !               reduce using rule 40 (expr -> expr % expr .)
    ID              reduce using rule 40 (expr -> expr % expr .)
    DEC             reduce using rule 40 (expr -> expr % expr .)
    INC             reduce using rule 40 (expr -> expr % expr .)
    IF              reduce using rule 40 (expr -> expr % expr .)
    FOR             reduce using rule 40 (expr -> expr % expr .)
    WHILE           reduce using rule 40 (expr -> expr % expr .)
    RETURN          reduce using rule 40 (expr -> expr % expr .)
    FN              reduce using rule 40 (expr -> expr % expr .)
    :               reduce using rule 40 (expr -> expr % expr .)
    ,               reduce using rule 40 (expr -> expr % expr .)


state 76

    (41) expr -> expr / expr .
    (40) expr -> expr . % expr
    (41) expr -> expr . / expr
    (42) expr -> expr . * expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    (48) expr -> expr . | expr
    (49) expr -> expr . ^ expr
    (50) expr -> expr . & expr
    (51) expr -> expr . GREATER expr
    (52) expr -> expr . LESS expr
    (53) expr -> expr . OR expr
    (54) expr -> expr . AND expr
    (55) expr -> expr . GREATEREQ expr
    (56) expr -> expr . LESSEQ expr
    (57) expr -> expr . NOTEQ expr
    (58) expr -> expr . EQEQ expr
    (60) expr -> expr . ? expr : expr
    SEP             reduce using rule 41 (expr -> expr / expr .)
    %               reduce using rule 41 (expr -> expr / expr .)
    /               reduce using rule 41 (expr -> expr / expr .)
    *               reduce using rule 41 (expr -> expr / expr .)
    -               reduce using rule 41 (expr -> expr / expr .)
    +               reduce using rule 41 (expr -> expr / expr .)
    |               reduce using rule 41 (expr -> expr / expr .)
    ^               reduce using rule 41 (expr -> expr / expr .)
    &               reduce using rule 41 (expr -> expr / expr .)
    GREATER         reduce using rule 41 (expr -> expr / expr .)
    LESS            reduce using rule 41 (expr -> expr / expr .)
    OR              reduce using rule 41 (expr -> expr / expr .)
    AND             reduce using rule 41 (expr -> expr / expr .)
    GREATEREQ       reduce using rule 41 (expr -> expr / expr .)
    LESSEQ          reduce using rule 41 (expr -> expr / expr .)
    NOTEQ           reduce using rule 41 (expr -> expr / expr .)
    EQEQ            reduce using rule 41 (expr -> expr / expr .)
    ?               reduce using rule 41 (expr -> expr / expr .)
    )               reduce using rule 41 (expr -> expr / expr .)
    {               reduce using rule 41 (expr -> expr / expr .)
    LET             reduce using rule 41 (expr -> expr / expr .)
    FALSE           reduce using rule 41 (expr -> expr / expr .)
    TRUE            reduce using rule 41 (expr -> expr / expr .)
    STRING          reduce using rule 41 (expr -> expr / expr .)
    FLOAT           reduce using rule 41 (expr -> expr / expr .)
    INT             reduce using rule 41 (expr -> expr / expr .)
    (               reduce using rule 41 (expr -> expr / expr .)
    !               reduce using rule 41 (expr -> expr / expr .)
    ID              reduce using rule 41 (expr -> expr / expr .)
    DEC             reduce using rule 41 (expr -> expr / expr .)
    INC             reduce using rule 41 (expr -> expr / expr .)
    IF              reduce using rule 41 (expr -> expr / expr .)
    FOR             reduce using rule 41 (expr -> expr / expr .)
    WHILE           reduce using rule 41 (expr -> expr / expr .)
    RETURN          reduce using rule 41 (expr -> expr / expr .)
    FN              reduce using rule 41 (expr -> expr / expr .)
    :               reduce using rule 41 (expr -> expr / expr .)
    ,               reduce using rule 41 (expr -> expr / expr .)


state 77

    (42) expr -> expr * expr .
    (40) expr -> expr . % expr
    (41) expr -> expr . / expr
    (42) expr -> expr . * expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    (48) expr -> expr . | expr
    (49) expr -> expr . ^ expr
    (50) expr -> expr . & expr
    (51) expr -> expr . GREATER expr
    (52) expr -> expr . LESS expr
    (53) expr -> expr . OR expr
    (54) expr -> expr . AND expr
    (55) expr -> expr . GREATEREQ expr
    (56) expr -> expr . LESSEQ expr
    (57) expr -> expr . NOTEQ expr
    (58) expr -> expr . EQEQ expr
    (60) expr -> expr . ? expr : expr
    SEP             reduce using rule 42 (expr -> expr * expr .)
    %               reduce using rule 42 (expr -> expr * expr .)
    /               reduce using rule 42 (expr -> expr * expr .)
    *               reduce using rule 42 (expr -> expr * expr .)
    -               reduce using rule 42 (expr -> expr * expr .)
    +               reduce using rule 42 (expr -> expr * expr .)
    |               reduce using rule 42 (expr -> expr * expr .)
    ^               reduce using rule 42 (expr -> expr * expr .)
    &               reduce using rule 42 (expr -> expr * expr .)
    GREATER         reduce using rule 42 (expr -> expr * expr .)
    LESS            reduce using rule 42 (expr -> expr * expr .)
    OR              reduce using rule 42 (expr -> expr * expr .)
    AND             reduce using rule 42 (expr -> expr * expr .)
    GREATEREQ       reduce using rule 42 (expr -> expr * expr .)
    LESSEQ          reduce using rule 42 (expr -> expr * expr .)
    NOTEQ           reduce using rule 42 (expr -> expr * expr .)
    EQEQ            reduce using rule 42 (expr -> expr * expr .)
    ?               reduce using rule 42 (expr -> expr * expr .)
    )               reduce using rule 42 (expr -> expr * expr .)
    {               reduce using rule 42 (expr -> expr * expr .)
    LET             reduce using rule 42 (expr -> expr * expr .)
    FALSE           reduce using rule 42 (expr -> expr * expr .)
    TRUE            reduce using rule 42 (expr -> expr * expr .)
    STRING          reduce using rule 42 (expr -> expr * expr .)
    FLOAT           reduce using rule 42 (expr -> expr * expr .)
    INT             reduce using rule 42 (expr -> expr * expr .)
    (               reduce using rule 42 (expr -> expr * expr .)
    !               reduce using rule 42 (expr -> expr * expr .)
    ID              reduce using rule 42 (expr -> expr * expr .)
    DEC             reduce using rule 42 (expr -> expr * expr .)
    INC             reduce using rule 42 (expr -> expr * expr .)
    IF              reduce using rule 42 (expr -> expr * expr .)
    FOR             reduce using rule 42 (expr -> expr * expr .)
    WHILE           reduce using rule 42 (expr -> expr * expr .)
    RETURN          reduce using rule 42 (expr -> expr * expr .)
    FN              reduce using rule 42 (expr -> expr * expr .)
    :               reduce using rule 42 (expr -> expr * expr .)
    ,               reduce using rule 42 (expr -> expr * expr .)


state 78

    (43) expr -> expr - expr .
    (40) expr -> expr . % expr
    (41) expr -> expr . / expr
    (42) expr -> expr . * expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    (48) expr -> expr . | expr
    (49) expr -> expr . ^ expr
    (50) expr -> expr . & expr
    (51) expr -> expr . GREATER expr
    (52) expr -> expr . LESS expr
    (53) expr -> expr . OR expr
    (54) expr -> expr . AND expr
    (55) expr -> expr . GREATEREQ expr
    (56) expr -> expr . LESSEQ expr
    (57) expr -> expr . NOTEQ expr
    (58) expr -> expr . EQEQ expr
    (60) expr -> expr . ? expr : expr
    SEP             reduce using rule 43 (expr -> expr - expr .)
    -               reduce using rule 43 (expr -> expr - expr .)
    +               reduce using rule 43 (expr -> expr - expr .)
    |               reduce using rule 43 (expr -> expr - expr .)
    ^               reduce using rule 43 (expr -> expr - expr .)
    &               reduce using rule 43 (expr -> expr - expr .)
    GREATER         reduce using rule 43 (expr -> expr - expr .)
    LESS            reduce using rule 43 (expr -> expr - expr .)
    OR              reduce using rule 43 (expr -> expr - expr .)
    AND             reduce using rule 43 (expr -> expr - expr .)
    GREATEREQ       reduce using rule 43 (expr -> expr - expr .)
    LESSEQ          reduce using rule 43 (expr -> expr - expr .)
    NOTEQ           reduce using rule 43 (expr -> expr - expr .)
    EQEQ            reduce using rule 43 (expr -> expr - expr .)
    ?               reduce using rule 43 (expr -> expr - expr .)
    )               reduce using rule 43 (expr -> expr - expr .)
    {               reduce using rule 43 (expr -> expr - expr .)
    LET             reduce using rule 43 (expr -> expr - expr .)
    FALSE           reduce using rule 43 (expr -> expr - expr .)
    TRUE            reduce using rule 43 (expr -> expr - expr .)
    STRING          reduce using rule 43 (expr -> expr - expr .)
    FLOAT           reduce using rule 43 (expr -> expr - expr .)
    INT             reduce using rule 43 (expr -> expr - expr .)
    (               reduce using rule 43 (expr -> expr - expr .)
    !               reduce using rule 43 (expr -> expr - expr .)
    ID              reduce using rule 43 (expr -> expr - expr .)
    DEC             reduce using rule 43 (expr -> expr - expr .)
    INC             reduce using rule 43 (expr -> expr - expr .)
    IF              reduce using rule 43 (expr -> expr - expr .)
    FOR             reduce using rule 43 (expr -> expr - expr .)
    WHILE           reduce using rule 43 (expr -> expr - expr .)
    RETURN          reduce using rule 43 (expr -> expr - expr .)
    FN              reduce using rule 43 (expr -> expr - expr .)
    :               reduce using rule 43 (expr -> expr - expr .)
    ,               reduce using rule 43 (expr -> expr - expr .)
    %               shift and go to state 34
    /               shift and go to state 35
    *               shift and go to state 36


state 79

    (44) expr -> expr + expr .
    (40) expr -> expr . % expr
    (41) expr -> expr . / expr
    (42) expr -> expr . * expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    (48) expr -> expr . | expr
    (49) expr -> expr . ^ expr
    (50) expr -> expr . & expr
    (51) expr -> expr . GREATER expr
    (52) expr -> expr . LESS expr
    (53) expr -> expr . OR expr
    (54) expr -> expr . AND expr
    (55) expr -> expr . GREATEREQ expr
    (56) expr -> expr . LESSEQ expr
    (57) expr -> expr . NOTEQ expr
    (58) expr -> expr . EQEQ expr
    (60) expr -> expr . ? expr : expr
    SEP             reduce using rule 44 (expr -> expr + expr .)
    -               reduce using rule 44 (expr -> expr + expr .)
    +               reduce using rule 44 (expr -> expr + expr .)
    |               reduce using rule 44 (expr -> expr + expr .)
    ^               reduce using rule 44 (expr -> expr + expr .)
    &               reduce using rule 44 (expr -> expr + expr .)
    GREATER         reduce using rule 44 (expr -> expr + expr .)
    LESS            reduce using rule 44 (expr -> expr + expr .)
    OR              reduce using rule 44 (expr -> expr + expr .)
    AND             reduce using rule 44 (expr -> expr + expr .)
    GREATEREQ       reduce using rule 44 (expr -> expr + expr .)
    LESSEQ          reduce using rule 44 (expr -> expr + expr .)
    NOTEQ           reduce using rule 44 (expr -> expr + expr .)
    EQEQ            reduce using rule 44 (expr -> expr + expr .)
    ?               reduce using rule 44 (expr -> expr + expr .)
    )               reduce using rule 44 (expr -> expr + expr .)
    {               reduce using rule 44 (expr -> expr + expr .)
    LET             reduce using rule 44 (expr -> expr + expr .)
    FALSE           reduce using rule 44 (expr -> expr + expr .)
    TRUE            reduce using rule 44 (expr -> expr + expr .)
    STRING          reduce using rule 44 (expr -> expr + expr .)
    FLOAT           reduce using rule 44 (expr -> expr + expr .)
    INT             reduce using rule 44 (expr -> expr + expr .)
    (               reduce using rule 44 (expr -> expr + expr .)
    !               reduce using rule 44 (expr -> expr + expr .)
    ID              reduce using rule 44 (expr -> expr + expr .)
    DEC             reduce using rule 44 (expr -> expr + expr .)
    INC             reduce using rule 44 (expr -> expr + expr .)
    IF              reduce using rule 44 (expr -> expr + expr .)
    FOR             reduce using rule 44 (expr -> expr + expr .)
    WHILE           reduce using rule 44 (expr -> expr + expr .)
    RETURN          reduce using rule 44 (expr -> expr + expr .)
    FN              reduce using rule 44 (expr -> expr + expr .)
    :               reduce using rule 44 (expr -> expr + expr .)
    ,               reduce using rule 44 (expr -> expr + expr .)
    %               shift and go to state 34
    /               shift and go to state 35
    *               shift and go to state 36


state 80

    (48) expr -> expr | expr .
    (40) expr -> expr . % expr
    (41) expr -> expr . / expr
    (42) expr -> expr . * expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    (48) expr -> expr . | expr
    (49) expr -> expr . ^ expr
    (50) expr -> expr . & expr
    (51) expr -> expr . GREATER expr
    (52) expr -> expr . LESS expr
    (53) expr -> expr . OR expr
    (54) expr -> expr . AND expr
    (55) expr -> expr . GREATEREQ expr
    (56) expr -> expr . LESSEQ expr
    (57) expr -> expr . NOTEQ expr
    (58) expr -> expr . EQEQ expr
    (60) expr -> expr . ? expr : expr
    SEP             reduce using rule 48 (expr -> expr | expr .)
    |               reduce using rule 48 (expr -> expr | expr .)
    OR              reduce using rule 48 (expr -> expr | expr .)
    AND             reduce using rule 48 (expr -> expr | expr .)
    ?               reduce using rule 48 (expr -> expr | expr .)
    )               reduce using rule 48 (expr -> expr | expr .)
    {               reduce using rule 48 (expr -> expr | expr .)
    LET             reduce using rule 48 (expr -> expr | expr .)
    FALSE           reduce using rule 48 (expr -> expr | expr .)
    TRUE            reduce using rule 48 (expr -> expr | expr .)
    STRING          reduce using rule 48 (expr -> expr | expr .)
    FLOAT           reduce using rule 48 (expr -> expr | expr .)
    INT             reduce using rule 48 (expr -> expr | expr .)
    (               reduce using rule 48 (expr -> expr | expr .)
    !               reduce using rule 48 (expr -> expr | expr .)
    ID              reduce using rule 48 (expr -> expr | expr .)
    DEC             reduce using rule 48 (expr -> expr | expr .)
    INC             reduce using rule 48 (expr -> expr | expr .)
    IF              reduce using rule 48 (expr -> expr | expr .)
    FOR             reduce using rule 48 (expr -> expr | expr .)
    WHILE           reduce using rule 48 (expr -> expr | expr .)
    RETURN          reduce using rule 48 (expr -> expr | expr .)
    FN              reduce using rule 48 (expr -> expr | expr .)
    :               reduce using rule 48 (expr -> expr | expr .)
    ,               reduce using rule 48 (expr -> expr | expr .)
    %               shift and go to state 34
    /               shift and go to state 35
    *               shift and go to state 36
    -               shift and go to state 37
    +               shift and go to state 38
    ^               shift and go to state 40
    &               shift and go to state 41
    GREATER         shift and go to state 42
    LESS            shift and go to state 43
    GREATEREQ       shift and go to state 46
    LESSEQ          shift and go to state 47
    NOTEQ           shift and go to state 48
    EQEQ            shift and go to state 49


state 81

    (49) expr -> expr ^ expr .
    (40) expr -> expr . % expr
    (41) expr -> expr . / expr
    (42) expr -> expr . * expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    (48) expr -> expr . | expr
    (49) expr -> expr . ^ expr
    (50) expr -> expr . & expr
    (51) expr -> expr . GREATER expr
    (52) expr -> expr . LESS expr
    (53) expr -> expr . OR expr
    (54) expr -> expr . AND expr
    (55) expr -> expr . GREATEREQ expr
    (56) expr -> expr . LESSEQ expr
    (57) expr -> expr . NOTEQ expr
    (58) expr -> expr . EQEQ expr
    (60) expr -> expr . ? expr : expr
    SEP             reduce using rule 49 (expr -> expr ^ expr .)
    |               reduce using rule 49 (expr -> expr ^ expr .)
    ^               reduce using rule 49 (expr -> expr ^ expr .)
    OR              reduce using rule 49 (expr -> expr ^ expr .)
    AND             reduce using rule 49 (expr -> expr ^ expr .)
    ?               reduce using rule 49 (expr -> expr ^ expr .)
    )               reduce using rule 49 (expr -> expr ^ expr .)
    {               reduce using rule 49 (expr -> expr ^ expr .)
    LET             reduce using rule 49 (expr -> expr ^ expr .)
    FALSE           reduce using rule 49 (expr -> expr ^ expr .)
    TRUE            reduce using rule 49 (expr -> expr ^ expr .)
    STRING          reduce using rule 49 (expr -> expr ^ expr .)
    FLOAT           reduce using rule 49 (expr -> expr ^ expr .)
    INT             reduce using rule 49 (expr -> expr ^ expr .)
    (               reduce using rule 49 (expr -> expr ^ expr .)
    !               reduce using rule 49 (expr -> expr ^ expr .)
    ID              reduce using rule 49 (expr -> expr ^ expr .)
    DEC             reduce using rule 49 (expr -> expr ^ expr .)
    INC             reduce using rule 49 (expr -> expr ^ expr .)
    IF              reduce using rule 49 (expr -> expr ^ expr .)
    FOR             reduce using rule 49 (expr -> expr ^ expr .)
    WHILE           reduce using rule 49 (expr -> expr ^ expr .)
    RETURN          reduce using rule 49 (expr -> expr ^ expr .)
    FN              reduce using rule 49 (expr -> expr ^ expr .)
    :               reduce using rule 49 (expr -> expr ^ expr .)
    ,               reduce using rule 49 (expr -> expr ^ expr .)
    %               shift and go to state 34
    /               shift and go to state 35
    *               shift and go to state 36
    -               shift and go to state 37
    +               shift and go to state 38
    &               shift and go to state 41
    GREATER         shift and go to state 42
    LESS            shift and go to state 43
    GREATEREQ       shift and go to state 46
    LESSEQ          shift and go to state 47
    NOTEQ           shift and go to state 48
    EQEQ            shift and go to state 49


state 82

    (50) expr -> expr & expr .
    (40) expr -> expr . % expr
    (41) expr -> expr . / expr
    (42) expr -> expr . * expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    (48) expr -> expr . | expr
    (49) expr -> expr . ^ expr
    (50) expr -> expr . & expr
    (51) expr -> expr . GREATER expr
    (52) expr -> expr . LESS expr
    (53) expr -> expr . OR expr
    (54) expr -> expr . AND expr
    (55) expr -> expr . GREATEREQ expr
    (56) expr -> expr . LESSEQ expr
    (57) expr -> expr . NOTEQ expr
    (58) expr -> expr . EQEQ expr
    (60) expr -> expr . ? expr : expr
    SEP             reduce using rule 50 (expr -> expr & expr .)
    |               reduce using rule 50 (expr -> expr & expr .)
    ^               reduce using rule 50 (expr -> expr & expr .)
    &               reduce using rule 50 (expr -> expr & expr .)
    OR              reduce using rule 50 (expr -> expr & expr .)
    AND             reduce using rule 50 (expr -> expr & expr .)
    ?               reduce using rule 50 (expr -> expr & expr .)
    )               reduce using rule 50 (expr -> expr & expr .)
    {               reduce using rule 50 (expr -> expr & expr .)
    LET             reduce using rule 50 (expr -> expr & expr .)
    FALSE           reduce using rule 50 (expr -> expr & expr .)
    TRUE            reduce using rule 50 (expr -> expr & expr .)
    STRING          reduce using rule 50 (expr -> expr & expr .)
    FLOAT           reduce using rule 50 (expr -> expr & expr .)
    INT             reduce using rule 50 (expr -> expr & expr .)
    (               reduce using rule 50 (expr -> expr & expr .)
    !               reduce using rule 50 (expr -> expr & expr .)
    ID              reduce using rule 50 (expr -> expr & expr .)
    DEC             reduce using rule 50 (expr -> expr & expr .)
    INC             reduce using rule 50 (expr -> expr & expr .)
    IF              reduce using rule 50 (expr -> expr & expr .)
    FOR             reduce using rule 50 (expr -> expr & expr .)
    WHILE           reduce using rule 50 (expr -> expr & expr .)
    RETURN          reduce using rule 50 (expr -> expr & expr .)
    FN              reduce using rule 50 (expr -> expr & expr .)
    :               reduce using rule 50 (expr -> expr & expr .)
    ,               reduce using rule 50 (expr -> expr & expr .)
    %               shift and go to state 34
    /               shift and go to state 35
    *               shift and go to state 36
    -               shift and go to state 37
    +               shift and go to state 38
    GREATER         shift and go to state 42
    LESS            shift and go to state 43
    GREATEREQ       shift and go to state 46
    LESSEQ          shift and go to state 47
    NOTEQ           shift and go to state 48
    EQEQ            shift and go to state 49


state 83

    (51) expr -> expr GREATER expr .
    (40) expr -> expr . % expr
    (41) expr -> expr . / expr
    (42) expr -> expr . * expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    (48) expr -> expr . | expr
    (49) expr -> expr . ^ expr
    (50) expr -> expr . & expr
    (51) expr -> expr . GREATER expr
    (52) expr -> expr . LESS expr
    (53) expr -> expr . OR expr
    (54) expr -> expr . AND expr
    (55) expr -> expr . GREATEREQ expr
    (56) expr -> expr . LESSEQ expr
    (57) expr -> expr . NOTEQ expr
    (58) expr -> expr . EQEQ expr
    (60) expr -> expr . ? expr : expr
    SEP             reduce using rule 51 (expr -> expr GREATER expr .)
    |               reduce using rule 51 (expr -> expr GREATER expr .)
    ^               reduce using rule 51 (expr -> expr GREATER expr .)
    &               reduce using rule 51 (expr -> expr GREATER expr .)
    GREATER         reduce using rule 51 (expr -> expr GREATER expr .)
    LESS            reduce using rule 51 (expr -> expr GREATER expr .)
    OR              reduce using rule 51 (expr -> expr GREATER expr .)
    AND             reduce using rule 51 (expr -> expr GREATER expr .)
    GREATEREQ       reduce using rule 51 (expr -> expr GREATER expr .)
    LESSEQ          reduce using rule 51 (expr -> expr GREATER expr .)
    NOTEQ           reduce using rule 51 (expr -> expr GREATER expr .)
    EQEQ            reduce using rule 51 (expr -> expr GREATER expr .)
    ?               reduce using rule 51 (expr -> expr GREATER expr .)
    )               reduce using rule 51 (expr -> expr GREATER expr .)
    {               reduce using rule 51 (expr -> expr GREATER expr .)
    LET             reduce using rule 51 (expr -> expr GREATER expr .)
    FALSE           reduce using rule 51 (expr -> expr GREATER expr .)
    TRUE            reduce using rule 51 (expr -> expr GREATER expr .)
    STRING          reduce using rule 51 (expr -> expr GREATER expr .)
    FLOAT           reduce using rule 51 (expr -> expr GREATER expr .)
    INT             reduce using rule 51 (expr -> expr GREATER expr .)
    (               reduce using rule 51 (expr -> expr GREATER expr .)
    !               reduce using rule 51 (expr -> expr GREATER expr .)
    ID              reduce using rule 51 (expr -> expr GREATER expr .)
    DEC             reduce using rule 51 (expr -> expr GREATER expr .)
    INC             reduce using rule 51 (expr -> expr GREATER expr .)
    IF              reduce using rule 51 (expr -> expr GREATER expr .)
    FOR             reduce using rule 51 (expr -> expr GREATER expr .)
    WHILE           reduce using rule 51 (expr -> expr GREATER expr .)
    RETURN          reduce using rule 51 (expr -> expr GREATER expr .)
    FN              reduce using rule 51 (expr -> expr GREATER expr .)
    :               reduce using rule 51 (expr -> expr GREATER expr .)
    ,               reduce using rule 51 (expr -> expr GREATER expr .)
    %               shift and go to state 34
    /               shift and go to state 35
    *               shift and go to state 36
    -               shift and go to state 37
    +               shift and go to state 38


state 84

    (52) expr -> expr LESS expr .
    (40) expr -> expr . % expr
    (41) expr -> expr . / expr
    (42) expr -> expr . * expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    (48) expr -> expr . | expr
    (49) expr -> expr . ^ expr
    (50) expr -> expr . & expr
    (51) expr -> expr . GREATER expr
    (52) expr -> expr . LESS expr
    (53) expr -> expr . OR expr
    (54) expr -> expr . AND expr
    (55) expr -> expr . GREATEREQ expr
    (56) expr -> expr . LESSEQ expr
    (57) expr -> expr . NOTEQ expr
    (58) expr -> expr . EQEQ expr
    (60) expr -> expr . ? expr : expr
    SEP             reduce using rule 52 (expr -> expr LESS expr .)
    |               reduce using rule 52 (expr -> expr LESS expr .)
    ^               reduce using rule 52 (expr -> expr LESS expr .)
    &               reduce using rule 52 (expr -> expr LESS expr .)
    GREATER         reduce using rule 52 (expr -> expr LESS expr .)
    LESS            reduce using rule 52 (expr -> expr LESS expr .)
    OR              reduce using rule 52 (expr -> expr LESS expr .)
    AND             reduce using rule 52 (expr -> expr LESS expr .)
    GREATEREQ       reduce using rule 52 (expr -> expr LESS expr .)
    LESSEQ          reduce using rule 52 (expr -> expr LESS expr .)
    NOTEQ           reduce using rule 52 (expr -> expr LESS expr .)
    EQEQ            reduce using rule 52 (expr -> expr LESS expr .)
    ?               reduce using rule 52 (expr -> expr LESS expr .)
    )               reduce using rule 52 (expr -> expr LESS expr .)
    {               reduce using rule 52 (expr -> expr LESS expr .)
    LET             reduce using rule 52 (expr -> expr LESS expr .)
    FALSE           reduce using rule 52 (expr -> expr LESS expr .)
    TRUE            reduce using rule 52 (expr -> expr LESS expr .)
    STRING          reduce using rule 52 (expr -> expr LESS expr .)
    FLOAT           reduce using rule 52 (expr -> expr LESS expr .)
    INT             reduce using rule 52 (expr -> expr LESS expr .)
    (               reduce using rule 52 (expr -> expr LESS expr .)
    !               reduce using rule 52 (expr -> expr LESS expr .)
    ID              reduce using rule 52 (expr -> expr LESS expr .)
    DEC             reduce using rule 52 (expr -> expr LESS expr .)
    INC             reduce using rule 52 (expr -> expr LESS expr .)
    IF              reduce using rule 52 (expr -> expr LESS expr .)
    FOR             reduce using rule 52 (expr -> expr LESS expr .)
    WHILE           reduce using rule 52 (expr -> expr LESS expr .)
    RETURN          reduce using rule 52 (expr -> expr LESS expr .)
    FN              reduce using rule 52 (expr -> expr LESS expr .)
    :               reduce using rule 52 (expr -> expr LESS expr .)
    ,               reduce using rule 52 (expr -> expr LESS expr .)
    %               shift and go to state 34
    /               shift and go to state 35
    *               shift and go to state 36
    -               shift and go to state 37
    +               shift and go to state 38


state 85

    (53) expr -> expr OR expr .
    (40) expr -> expr . % expr
    (41) expr -> expr . / expr
    (42) expr -> expr . * expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    (48) expr -> expr . | expr
    (49) expr -> expr . ^ expr
    (50) expr -> expr . & expr
    (51) expr -> expr . GREATER expr
    (52) expr -> expr . LESS expr
    (53) expr -> expr . OR expr
    (54) expr -> expr . AND expr
    (55) expr -> expr . GREATEREQ expr
    (56) expr -> expr . LESSEQ expr
    (57) expr -> expr . NOTEQ expr
    (58) expr -> expr . EQEQ expr
    (60) expr -> expr . ? expr : expr
    SEP             reduce using rule 53 (expr -> expr OR expr .)
    OR              reduce using rule 53 (expr -> expr OR expr .)
    ?               reduce using rule 53 (expr -> expr OR expr .)
    )               reduce using rule 53 (expr -> expr OR expr .)
    {               reduce using rule 53 (expr -> expr OR expr .)
    LET             reduce using rule 53 (expr -> expr OR expr .)
    FALSE           reduce using rule 53 (expr -> expr OR expr .)
    TRUE            reduce using rule 53 (expr -> expr OR expr .)
    STRING          reduce using rule 53 (expr -> expr OR expr .)
    FLOAT           reduce using rule 53 (expr -> expr OR expr .)
    INT             reduce using rule 53 (expr -> expr OR expr .)
    (               reduce using rule 53 (expr -> expr OR expr .)
    !               reduce using rule 53 (expr -> expr OR expr .)
    ID              reduce using rule 53 (expr -> expr OR expr .)
    DEC             reduce using rule 53 (expr -> expr OR expr .)
    INC             reduce using rule 53 (expr -> expr OR expr .)
    IF              reduce using rule 53 (expr -> expr OR expr .)
    FOR             reduce using rule 53 (expr -> expr OR expr .)
    WHILE           reduce using rule 53 (expr -> expr OR expr .)
    RETURN          reduce using rule 53 (expr -> expr OR expr .)
    FN              reduce using rule 53 (expr -> expr OR expr .)
    :               reduce using rule 53 (expr -> expr OR expr .)
    ,               reduce using rule 53 (expr -> expr OR expr .)
    %               shift and go to state 34
    /               shift and go to state 35
    *               shift and go to state 36
    -               shift and go to state 37
    +               shift and go to state 38
    |               shift and go to state 39
    ^               shift and go to state 40
    &               shift and go to state 41
    GREATER         shift and go to state 42
    LESS            shift and go to state 43
    AND             shift and go to state 45
    GREATEREQ       shift and go to state 46
    LESSEQ          shift and go to state 47
    NOTEQ           shift and go to state 48
    EQEQ            shift and go to state 49


state 86

    (54) expr -> expr AND expr .
    (40) expr -> expr . % expr
    (41) expr -> expr . / expr
    (42) expr -> expr . * expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    (48) expr -> expr . | expr
    (49) expr -> expr . ^ expr
    (50) expr -> expr . & expr
    (51) expr -> expr . GREATER expr
    (52) expr -> expr . LESS expr
    (53) expr -> expr . OR expr
    (54) expr -> expr . AND expr
    (55) expr -> expr . GREATEREQ expr
    (56) expr -> expr . LESSEQ expr
    (57) expr -> expr . NOTEQ expr
    (58) expr -> expr . EQEQ expr
    (60) expr -> expr . ? expr : expr
    SEP             reduce using rule 54 (expr -> expr AND expr .)
    OR              reduce using rule 54 (expr -> expr AND expr .)
    AND             reduce using rule 54 (expr -> expr AND expr .)
    ?               reduce using rule 54 (expr -> expr AND expr .)
    )               reduce using rule 54 (expr -> expr AND expr .)
    {               reduce using rule 54 (expr -> expr AND expr .)
    LET             reduce using rule 54 (expr -> expr AND expr .)
    FALSE           reduce using rule 54 (expr -> expr AND expr .)
    TRUE            reduce using rule 54 (expr -> expr AND expr .)
    STRING          reduce using rule 54 (expr -> expr AND expr .)
    FLOAT           reduce using rule 54 (expr -> expr AND expr .)
    INT             reduce using rule 54 (expr -> expr AND expr .)
    (               reduce using rule 54 (expr -> expr AND expr .)
    !               reduce using rule 54 (expr -> expr AND expr .)
    ID              reduce using rule 54 (expr -> expr AND expr .)
    DEC             reduce using rule 54 (expr -> expr AND expr .)
    INC             reduce using rule 54 (expr -> expr AND expr .)
    IF              reduce using rule 54 (expr -> expr AND expr .)
    FOR             reduce using rule 54 (expr -> expr AND expr .)
    WHILE           reduce using rule 54 (expr -> expr AND expr .)
    RETURN          reduce using rule 54 (expr -> expr AND expr .)
    FN              reduce using rule 54 (expr -> expr AND expr .)
    :               reduce using rule 54 (expr -> expr AND expr .)
    ,               reduce using rule 54 (expr -> expr AND expr .)
    %               shift and go to state 34
    /               shift and go to state 35
    *               shift and go to state 36
    -               shift and go to state 37
    +               shift and go to state 38
    |               shift and go to state 39
    ^               shift and go to state 40
    &               shift and go to state 41
    GREATER         shift and go to state 42
    LESS            shift and go to state 43
    GREATEREQ       shift and go to state 46
    LESSEQ          shift and go to state 47
    NOTEQ           shift and go to state 48
    EQEQ            shift and go to state 49


state 87

    (55) expr -> expr GREATEREQ expr .
    (40) expr -> expr . % expr
    (41) expr -> expr . / expr
    (42) expr -> expr . * expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    (48) expr -> expr . | expr
    (49) expr -> expr . ^ expr
    (50) expr -> expr . & expr
    (51) expr -> expr . GREATER expr
    (52) expr -> expr . LESS expr
    (53) expr -> expr . OR expr
    (54) expr -> expr . AND expr
    (55) expr -> expr . GREATEREQ expr
    (56) expr -> expr . LESSEQ expr
    (57) expr -> expr . NOTEQ expr
    (58) expr -> expr . EQEQ expr
    (60) expr -> expr . ? expr : expr
    SEP             reduce using rule 55 (expr -> expr GREATEREQ expr .)
    |               reduce using rule 55 (expr -> expr GREATEREQ expr .)
    ^               reduce using rule 55 (expr -> expr GREATEREQ expr .)
    &               reduce using rule 55 (expr -> expr GREATEREQ expr .)
    GREATER         reduce using rule 55 (expr -> expr GREATEREQ expr .)
    LESS            reduce using rule 55 (expr -> expr GREATEREQ expr .)
    OR              reduce using rule 55 (expr -> expr GREATEREQ expr .)
    AND             reduce using rule 55 (expr -> expr GREATEREQ expr .)
    GREATEREQ       reduce using rule 55 (expr -> expr GREATEREQ expr .)
    LESSEQ          reduce using rule 55 (expr -> expr GREATEREQ expr .)
    NOTEQ           reduce using rule 55 (expr -> expr GREATEREQ expr .)
    EQEQ            reduce using rule 55 (expr -> expr GREATEREQ expr .)
    ?               reduce using rule 55 (expr -> expr GREATEREQ expr .)
    )               reduce using rule 55 (expr -> expr GREATEREQ expr .)
    {               reduce using rule 55 (expr -> expr GREATEREQ expr .)
    LET             reduce using rule 55 (expr -> expr GREATEREQ expr .)
    FALSE           reduce using rule 55 (expr -> expr GREATEREQ expr .)
    TRUE            reduce using rule 55 (expr -> expr GREATEREQ expr .)
    STRING          reduce using rule 55 (expr -> expr GREATEREQ expr .)
    FLOAT           reduce using rule 55 (expr -> expr GREATEREQ expr .)
    INT             reduce using rule 55 (expr -> expr GREATEREQ expr .)
    (               reduce using rule 55 (expr -> expr GREATEREQ expr .)
    !               reduce using rule 55 (expr -> expr GREATEREQ expr .)
    ID              reduce using rule 55 (expr -> expr GREATEREQ expr .)
    DEC             reduce using rule 55 (expr -> expr GREATEREQ expr .)
    INC             reduce using rule 55 (expr -> expr GREATEREQ expr .)
    IF              reduce using rule 55 (expr -> expr GREATEREQ expr .)
    FOR             reduce using rule 55 (expr -> expr GREATEREQ expr .)
    WHILE           reduce using rule 55 (expr -> expr GREATEREQ expr .)
    RETURN          reduce using rule 55 (expr -> expr GREATEREQ expr .)
    FN              reduce using rule 55 (expr -> expr GREATEREQ expr .)
    :               reduce using rule 55 (expr -> expr GREATEREQ expr .)
    ,               reduce using rule 55 (expr -> expr GREATEREQ expr .)
    %               shift and go to state 34
    /               shift and go to state 35
    *               shift and go to state 36
    -               shift and go to state 37
    +               shift and go to state 38


state 88

    (56) expr -> expr LESSEQ expr .
    (40) expr -> expr . % expr
    (41) expr -> expr . / expr
    (42) expr -> expr . * expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    (48) expr -> expr . | expr
    (49) expr -> expr . ^ expr
    (50) expr -> expr . & expr
    (51) expr -> expr . GREATER expr
    (52) expr -> expr . LESS expr
    (53) expr -> expr . OR expr
    (54) expr -> expr . AND expr
    (55) expr -> expr . GREATEREQ expr
    (56) expr -> expr . LESSEQ expr
    (57) expr -> expr . NOTEQ expr
    (58) expr -> expr . EQEQ expr
    (60) expr -> expr . ? expr : expr
    SEP             reduce using rule 56 (expr -> expr LESSEQ expr .)
    |               reduce using rule 56 (expr -> expr LESSEQ expr .)
    ^               reduce using rule 56 (expr -> expr LESSEQ expr .)
    &               reduce using rule 56 (expr -> expr LESSEQ expr .)
    GREATER         reduce using rule 56 (expr -> expr LESSEQ expr .)
    LESS            reduce using rule 56 (expr -> expr LESSEQ expr .)
    OR              reduce using rule 56 (expr -> expr LESSEQ expr .)
    AND             reduce using rule 56 (expr -> expr LESSEQ expr .)
    GREATEREQ       reduce using rule 56 (expr -> expr LESSEQ expr .)
    LESSEQ          reduce using rule 56 (expr -> expr LESSEQ expr .)
    NOTEQ           reduce using rule 56 (expr -> expr LESSEQ expr .)
    EQEQ            reduce using rule 56 (expr -> expr LESSEQ expr .)
    ?               reduce using rule 56 (expr -> expr LESSEQ expr .)
    )               reduce using rule 56 (expr -> expr LESSEQ expr .)
    {               reduce using rule 56 (expr -> expr LESSEQ expr .)
    LET             reduce using rule 56 (expr -> expr LESSEQ expr .)
    FALSE           reduce using rule 56 (expr -> expr LESSEQ expr .)
    TRUE            reduce using rule 56 (expr -> expr LESSEQ expr .)
    STRING          reduce using rule 56 (expr -> expr LESSEQ expr .)
    FLOAT           reduce using rule 56 (expr -> expr LESSEQ expr .)
    INT             reduce using rule 56 (expr -> expr LESSEQ expr .)
    (               reduce using rule 56 (expr -> expr LESSEQ expr .)
    !               reduce using rule 56 (expr -> expr LESSEQ expr .)
    ID              reduce using rule 56 (expr -> expr LESSEQ expr .)
    DEC             reduce using rule 56 (expr -> expr LESSEQ expr .)
    INC             reduce using rule 56 (expr -> expr LESSEQ expr .)
    IF              reduce using rule 56 (expr -> expr LESSEQ expr .)
    FOR             reduce using rule 56 (expr -> expr LESSEQ expr .)
    WHILE           reduce using rule 56 (expr -> expr LESSEQ expr .)
    RETURN          reduce using rule 56 (expr -> expr LESSEQ expr .)
    FN              reduce using rule 56 (expr -> expr LESSEQ expr .)
    :               reduce using rule 56 (expr -> expr LESSEQ expr .)
    ,               reduce using rule 56 (expr -> expr LESSEQ expr .)
    %               shift and go to state 34
    /               shift and go to state 35
    *               shift and go to state 36
    -               shift and go to state 37
    +               shift and go to state 38


state 89

    (57) expr -> expr NOTEQ expr .
    (40) expr -> expr . % expr
    (41) expr -> expr . / expr
    (42) expr -> expr . * expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    (48) expr -> expr . | expr
    (49) expr -> expr . ^ expr
    (50) expr -> expr . & expr
    (51) expr -> expr . GREATER expr
    (52) expr -> expr . LESS expr
    (53) expr -> expr . OR expr
    (54) expr -> expr . AND expr
    (55) expr -> expr . GREATEREQ expr
    (56) expr -> expr . LESSEQ expr
    (57) expr -> expr . NOTEQ expr
    (58) expr -> expr . EQEQ expr
    (60) expr -> expr . ? expr : expr
    SEP             reduce using rule 57 (expr -> expr NOTEQ expr .)
    |               reduce using rule 57 (expr -> expr NOTEQ expr .)
    ^               reduce using rule 57 (expr -> expr NOTEQ expr .)
    &               reduce using rule 57 (expr -> expr NOTEQ expr .)
    OR              reduce using rule 57 (expr -> expr NOTEQ expr .)
    AND             reduce using rule 57 (expr -> expr NOTEQ expr .)
    NOTEQ           reduce using rule 57 (expr -> expr NOTEQ expr .)
    EQEQ            reduce using rule 57 (expr -> expr NOTEQ expr .)
    ?               reduce using rule 57 (expr -> expr NOTEQ expr .)
    )               reduce using rule 57 (expr -> expr NOTEQ expr .)
    {               reduce using rule 57 (expr -> expr NOTEQ expr .)
    LET             reduce using rule 57 (expr -> expr NOTEQ expr .)
    FALSE           reduce using rule 57 (expr -> expr NOTEQ expr .)
    TRUE            reduce using rule 57 (expr -> expr NOTEQ expr .)
    STRING          reduce using rule 57 (expr -> expr NOTEQ expr .)
    FLOAT           reduce using rule 57 (expr -> expr NOTEQ expr .)
    INT             reduce using rule 57 (expr -> expr NOTEQ expr .)
    (               reduce using rule 57 (expr -> expr NOTEQ expr .)
    !               reduce using rule 57 (expr -> expr NOTEQ expr .)
    ID              reduce using rule 57 (expr -> expr NOTEQ expr .)
    DEC             reduce using rule 57 (expr -> expr NOTEQ expr .)
    INC             reduce using rule 57 (expr -> expr NOTEQ expr .)
    IF              reduce using rule 57 (expr -> expr NOTEQ expr .)
    FOR             reduce using rule 57 (expr -> expr NOTEQ expr .)
    WHILE           reduce using rule 57 (expr -> expr NOTEQ expr .)
    RETURN          reduce using rule 57 (expr -> expr NOTEQ expr .)
    FN              reduce using rule 57 (expr -> expr NOTEQ expr .)
    :               reduce using rule 57 (expr -> expr NOTEQ expr .)
    ,               reduce using rule 57 (expr -> expr NOTEQ expr .)
    %               shift and go to state 34
    /               shift and go to state 35
    *               shift and go to state 36
    -               shift and go to state 37
    +               shift and go to state 38
    GREATER         shift and go to state 42
    LESS            shift and go to state 43
    GREATEREQ       shift and go to state 46
    LESSEQ          shift and go to state 47


state 90

    (58) expr -> expr EQEQ expr .
    (40) expr -> expr . % expr
    (41) expr -> expr . / expr
    (42) expr -> expr . * expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    (48) expr -> expr . | expr
    (49) expr -> expr . ^ expr
    (50) expr -> expr . & expr
    (51) expr -> expr . GREATER expr
    (52) expr -> expr . LESS expr
    (53) expr -> expr . OR expr
    (54) expr -> expr . AND expr
    (55) expr -> expr . GREATEREQ expr
    (56) expr -> expr . LESSEQ expr
    (57) expr -> expr . NOTEQ expr
    (58) expr -> expr . EQEQ expr
    (60) expr -> expr . ? expr : expr
    SEP             reduce using rule 58 (expr -> expr EQEQ expr .)
    |               reduce using rule 58 (expr -> expr EQEQ expr .)
    ^               reduce using rule 58 (expr -> expr EQEQ expr .)
    &               reduce using rule 58 (expr -> expr EQEQ expr .)
    OR              reduce using rule 58 (expr -> expr EQEQ expr .)
    AND             reduce using rule 58 (expr -> expr EQEQ expr .)
    NOTEQ           reduce using rule 58 (expr -> expr EQEQ expr .)
    EQEQ            reduce using rule 58 (expr -> expr EQEQ expr .)
    ?               reduce using rule 58 (expr -> expr EQEQ expr .)
    )               reduce using rule 58 (expr -> expr EQEQ expr .)
    {               reduce using rule 58 (expr -> expr EQEQ expr .)
    LET             reduce using rule 58 (expr -> expr EQEQ expr .)
    FALSE           reduce using rule 58 (expr -> expr EQEQ expr .)
    TRUE            reduce using rule 58 (expr -> expr EQEQ expr .)
    STRING          reduce using rule 58 (expr -> expr EQEQ expr .)
    FLOAT           reduce using rule 58 (expr -> expr EQEQ expr .)
    INT             reduce using rule 58 (expr -> expr EQEQ expr .)
    (               reduce using rule 58 (expr -> expr EQEQ expr .)
    !               reduce using rule 58 (expr -> expr EQEQ expr .)
    ID              reduce using rule 58 (expr -> expr EQEQ expr .)
    DEC             reduce using rule 58 (expr -> expr EQEQ expr .)
    INC             reduce using rule 58 (expr -> expr EQEQ expr .)
    IF              reduce using rule 58 (expr -> expr EQEQ expr .)
    FOR             reduce using rule 58 (expr -> expr EQEQ expr .)
    WHILE           reduce using rule 58 (expr -> expr EQEQ expr .)
    RETURN          reduce using rule 58 (expr -> expr EQEQ expr .)
    FN              reduce using rule 58 (expr -> expr EQEQ expr .)
    :               reduce using rule 58 (expr -> expr EQEQ expr .)
    ,               reduce using rule 58 (expr -> expr EQEQ expr .)
    %               shift and go to state 34
    /               shift and go to state 35
    *               shift and go to state 36
    -               shift and go to state 37
    +               shift and go to state 38
    GREATER         shift and go to state 42
    LESS            shift and go to state 43
    GREATEREQ       shift and go to state 46
    LESSEQ          shift and go to state 47


state 91

    (60) expr -> expr ? expr . : expr
    (40) expr -> expr . % expr
    (41) expr -> expr . / expr
    (42) expr -> expr . * expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    (48) expr -> expr . | expr
    (49) expr -> expr . ^ expr
    (50) expr -> expr . & expr
    (51) expr -> expr . GREATER expr
    (52) expr -> expr . LESS expr
    (53) expr -> expr . OR expr
    (54) expr -> expr . AND expr
    (55) expr -> expr . GREATEREQ expr
    (56) expr -> expr . LESSEQ expr
    (57) expr -> expr . NOTEQ expr
    (58) expr -> expr . EQEQ expr
    (60) expr -> expr . ? expr : expr
    :               shift and go to state 114
    %               shift and go to state 34
    /               shift and go to state 35
    *               shift and go to state 36
    -               shift and go to state 37
    +               shift and go to state 38
    |               shift and go to state 39
    ^               shift and go to state 40
    &               shift and go to state 41
    GREATER         shift and go to state 42
    LESS            shift and go to state 43
    OR              shift and go to state 44
    AND             shift and go to state 45
    GREATEREQ       shift and go to state 46
    LESSEQ          shift and go to state 47
    NOTEQ           shift and go to state 48
    EQEQ            shift and go to state 49
    ?               shift and go to state 50


state 92

    (7) statement -> LET var : . var_type SEP
    (14) var_type -> . BOOL_TYPE
    (15) var_type -> . STRING_TYPE
    (16) var_type -> . FLOAT_TYPE
    (17) var_type -> . INT_TYPE
    BOOL_TYPE       shift and go to state 116
    STRING_TYPE     shift and go to state 117
    FLOAT_TYPE      shift and go to state 118
    INT_TYPE        shift and go to state 119

    var_type                       shift and go to state 115

state 93

    (19) var_define -> LET var ASSIGN . expr
    (33) expr -> . var
    (34) expr -> . FALSE
    (35) expr -> . TRUE
    (36) expr -> . STRING
    (37) expr -> . FLOAT
    (38) expr -> . INT
    (39) expr -> . ( expr )
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ! expr
    (46) expr -> . + expr
    (47) expr -> . - expr
    (48) expr -> . expr | expr
    (49) expr -> . expr ^ expr
    (50) expr -> . expr & expr
    (51) expr -> . expr GREATER expr
    (52) expr -> . expr LESS expr
    (53) expr -> . expr OR expr
    (54) expr -> . expr AND expr
    (55) expr -> . expr GREATEREQ expr
    (56) expr -> . expr LESSEQ expr
    (57) expr -> . expr NOTEQ expr
    (58) expr -> . expr EQEQ expr
    (59) expr -> . ID ( args )
    (60) expr -> . expr ? expr : expr
    (61) var -> . ID
    FALSE           shift and go to state 15
    TRUE            shift and go to state 16
    STRING          shift and go to state 17
    FLOAT           shift and go to state 18
    INT             shift and go to state 19
    (               shift and go to state 20
    !               shift and go to state 23
    +               shift and go to state 22
    -               shift and go to state 21
    ID              shift and go to state 24

    var                            shift and go to state 62
    expr                           shift and go to state 120

state 94

    (23) var_assign -> var MODULOASGN expr .
    (40) expr -> expr . % expr
    (41) expr -> expr . / expr
    (42) expr -> expr . * expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    (48) expr -> expr . | expr
    (49) expr -> expr . ^ expr
    (50) expr -> expr . & expr
    (51) expr -> expr . GREATER expr
    (52) expr -> expr . LESS expr
    (53) expr -> expr . OR expr
    (54) expr -> expr . AND expr
    (55) expr -> expr . GREATEREQ expr
    (56) expr -> expr . LESSEQ expr
    (57) expr -> expr . NOTEQ expr
    (58) expr -> expr . EQEQ expr
    (60) expr -> expr . ? expr : expr
    SEP             reduce using rule 23 (var_assign -> var MODULOASGN expr .)
    {               reduce using rule 23 (var_assign -> var MODULOASGN expr .)
    LET             reduce using rule 23 (var_assign -> var MODULOASGN expr .)
    FALSE           reduce using rule 23 (var_assign -> var MODULOASGN expr .)
    TRUE            reduce using rule 23 (var_assign -> var MODULOASGN expr .)
    STRING          reduce using rule 23 (var_assign -> var MODULOASGN expr .)
    FLOAT           reduce using rule 23 (var_assign -> var MODULOASGN expr .)
    INT             reduce using rule 23 (var_assign -> var MODULOASGN expr .)
    (               reduce using rule 23 (var_assign -> var MODULOASGN expr .)
    !               reduce using rule 23 (var_assign -> var MODULOASGN expr .)
    ID              reduce using rule 23 (var_assign -> var MODULOASGN expr .)
    DEC             reduce using rule 23 (var_assign -> var MODULOASGN expr .)
    INC             reduce using rule 23 (var_assign -> var MODULOASGN expr .)
    IF              reduce using rule 23 (var_assign -> var MODULOASGN expr .)
    FOR             reduce using rule 23 (var_assign -> var MODULOASGN expr .)
    WHILE           reduce using rule 23 (var_assign -> var MODULOASGN expr .)
    RETURN          reduce using rule 23 (var_assign -> var MODULOASGN expr .)
    FN              reduce using rule 23 (var_assign -> var MODULOASGN expr .)
    %               shift and go to state 34
    /               shift and go to state 35
    *               shift and go to state 36
    -               shift and go to state 37
    +               shift and go to state 38
    |               shift and go to state 39
    ^               shift and go to state 40
    &               shift and go to state 41
    GREATER         shift and go to state 42
    LESS            shift and go to state 43
    OR              shift and go to state 44
    AND             shift and go to state 45
    GREATEREQ       shift and go to state 46
    LESSEQ          shift and go to state 47
    NOTEQ           shift and go to state 48
    EQEQ            shift and go to state 49
    ?               shift and go to state 50


state 95

    (24) var_assign -> var SLASHASGN expr .
    (40) expr -> expr . % expr
    (41) expr -> expr . / expr
    (42) expr -> expr . * expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    (48) expr -> expr . | expr
    (49) expr -> expr . ^ expr
    (50) expr -> expr . & expr
    (51) expr -> expr . GREATER expr
    (52) expr -> expr . LESS expr
    (53) expr -> expr . OR expr
    (54) expr -> expr . AND expr
    (55) expr -> expr . GREATEREQ expr
    (56) expr -> expr . LESSEQ expr
    (57) expr -> expr . NOTEQ expr
    (58) expr -> expr . EQEQ expr
    (60) expr -> expr . ? expr : expr
    SEP             reduce using rule 24 (var_assign -> var SLASHASGN expr .)
    {               reduce using rule 24 (var_assign -> var SLASHASGN expr .)
    LET             reduce using rule 24 (var_assign -> var SLASHASGN expr .)
    FALSE           reduce using rule 24 (var_assign -> var SLASHASGN expr .)
    TRUE            reduce using rule 24 (var_assign -> var SLASHASGN expr .)
    STRING          reduce using rule 24 (var_assign -> var SLASHASGN expr .)
    FLOAT           reduce using rule 24 (var_assign -> var SLASHASGN expr .)
    INT             reduce using rule 24 (var_assign -> var SLASHASGN expr .)
    (               reduce using rule 24 (var_assign -> var SLASHASGN expr .)
    !               reduce using rule 24 (var_assign -> var SLASHASGN expr .)
    ID              reduce using rule 24 (var_assign -> var SLASHASGN expr .)
    DEC             reduce using rule 24 (var_assign -> var SLASHASGN expr .)
    INC             reduce using rule 24 (var_assign -> var SLASHASGN expr .)
    IF              reduce using rule 24 (var_assign -> var SLASHASGN expr .)
    FOR             reduce using rule 24 (var_assign -> var SLASHASGN expr .)
    WHILE           reduce using rule 24 (var_assign -> var SLASHASGN expr .)
    RETURN          reduce using rule 24 (var_assign -> var SLASHASGN expr .)
    FN              reduce using rule 24 (var_assign -> var SLASHASGN expr .)
    %               shift and go to state 34
    /               shift and go to state 35
    *               shift and go to state 36
    -               shift and go to state 37
    +               shift and go to state 38
    |               shift and go to state 39
    ^               shift and go to state 40
    &               shift and go to state 41
    GREATER         shift and go to state 42
    LESS            shift and go to state 43
    OR              shift and go to state 44
    AND             shift and go to state 45
    GREATEREQ       shift and go to state 46
    LESSEQ          shift and go to state 47
    NOTEQ           shift and go to state 48
    EQEQ            shift and go to state 49
    ?               shift and go to state 50


state 96

    (25) var_assign -> var STARASGN expr .
    (40) expr -> expr . % expr
    (41) expr -> expr . / expr
    (42) expr -> expr . * expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    (48) expr -> expr . | expr
    (49) expr -> expr . ^ expr
    (50) expr -> expr . & expr
    (51) expr -> expr . GREATER expr
    (52) expr -> expr . LESS expr
    (53) expr -> expr . OR expr
    (54) expr -> expr . AND expr
    (55) expr -> expr . GREATEREQ expr
    (56) expr -> expr . LESSEQ expr
    (57) expr -> expr . NOTEQ expr
    (58) expr -> expr . EQEQ expr
    (60) expr -> expr . ? expr : expr
    SEP             reduce using rule 25 (var_assign -> var STARASGN expr .)
    {               reduce using rule 25 (var_assign -> var STARASGN expr .)
    LET             reduce using rule 25 (var_assign -> var STARASGN expr .)
    FALSE           reduce using rule 25 (var_assign -> var STARASGN expr .)
    TRUE            reduce using rule 25 (var_assign -> var STARASGN expr .)
    STRING          reduce using rule 25 (var_assign -> var STARASGN expr .)
    FLOAT           reduce using rule 25 (var_assign -> var STARASGN expr .)
    INT             reduce using rule 25 (var_assign -> var STARASGN expr .)
    (               reduce using rule 25 (var_assign -> var STARASGN expr .)
    !               reduce using rule 25 (var_assign -> var STARASGN expr .)
    ID              reduce using rule 25 (var_assign -> var STARASGN expr .)
    DEC             reduce using rule 25 (var_assign -> var STARASGN expr .)
    INC             reduce using rule 25 (var_assign -> var STARASGN expr .)
    IF              reduce using rule 25 (var_assign -> var STARASGN expr .)
    FOR             reduce using rule 25 (var_assign -> var STARASGN expr .)
    WHILE           reduce using rule 25 (var_assign -> var STARASGN expr .)
    RETURN          reduce using rule 25 (var_assign -> var STARASGN expr .)
    FN              reduce using rule 25 (var_assign -> var STARASGN expr .)
    %               shift and go to state 34
    /               shift and go to state 35
    *               shift and go to state 36
    -               shift and go to state 37
    +               shift and go to state 38
    |               shift and go to state 39
    ^               shift and go to state 40
    &               shift and go to state 41
    GREATER         shift and go to state 42
    LESS            shift and go to state 43
    OR              shift and go to state 44
    AND             shift and go to state 45
    GREATEREQ       shift and go to state 46
    LESSEQ          shift and go to state 47
    NOTEQ           shift and go to state 48
    EQEQ            shift and go to state 49
    ?               shift and go to state 50


state 97

    (26) var_assign -> var MINUSASGN expr .
    (40) expr -> expr . % expr
    (41) expr -> expr . / expr
    (42) expr -> expr . * expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    (48) expr -> expr . | expr
    (49) expr -> expr . ^ expr
    (50) expr -> expr . & expr
    (51) expr -> expr . GREATER expr
    (52) expr -> expr . LESS expr
    (53) expr -> expr . OR expr
    (54) expr -> expr . AND expr
    (55) expr -> expr . GREATEREQ expr
    (56) expr -> expr . LESSEQ expr
    (57) expr -> expr . NOTEQ expr
    (58) expr -> expr . EQEQ expr
    (60) expr -> expr . ? expr : expr
    SEP             reduce using rule 26 (var_assign -> var MINUSASGN expr .)
    {               reduce using rule 26 (var_assign -> var MINUSASGN expr .)
    LET             reduce using rule 26 (var_assign -> var MINUSASGN expr .)
    FALSE           reduce using rule 26 (var_assign -> var MINUSASGN expr .)
    TRUE            reduce using rule 26 (var_assign -> var MINUSASGN expr .)
    STRING          reduce using rule 26 (var_assign -> var MINUSASGN expr .)
    FLOAT           reduce using rule 26 (var_assign -> var MINUSASGN expr .)
    INT             reduce using rule 26 (var_assign -> var MINUSASGN expr .)
    (               reduce using rule 26 (var_assign -> var MINUSASGN expr .)
    !               reduce using rule 26 (var_assign -> var MINUSASGN expr .)
    ID              reduce using rule 26 (var_assign -> var MINUSASGN expr .)
    DEC             reduce using rule 26 (var_assign -> var MINUSASGN expr .)
    INC             reduce using rule 26 (var_assign -> var MINUSASGN expr .)
    IF              reduce using rule 26 (var_assign -> var MINUSASGN expr .)
    FOR             reduce using rule 26 (var_assign -> var MINUSASGN expr .)
    WHILE           reduce using rule 26 (var_assign -> var MINUSASGN expr .)
    RETURN          reduce using rule 26 (var_assign -> var MINUSASGN expr .)
    FN              reduce using rule 26 (var_assign -> var MINUSASGN expr .)
    %               shift and go to state 34
    /               shift and go to state 35
    *               shift and go to state 36
    -               shift and go to state 37
    +               shift and go to state 38
    |               shift and go to state 39
    ^               shift and go to state 40
    &               shift and go to state 41
    GREATER         shift and go to state 42
    LESS            shift and go to state 43
    OR              shift and go to state 44
    AND             shift and go to state 45
    GREATEREQ       shift and go to state 46
    LESSEQ          shift and go to state 47
    NOTEQ           shift and go to state 48
    EQEQ            shift and go to state 49
    ?               shift and go to state 50


state 98

    (27) var_assign -> var PLUSASGN expr .
    (40) expr -> expr . % expr
    (41) expr -> expr . / expr
    (42) expr -> expr . * expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    (48) expr -> expr . | expr
    (49) expr -> expr . ^ expr
    (50) expr -> expr . & expr
    (51) expr -> expr . GREATER expr
    (52) expr -> expr . LESS expr
    (53) expr -> expr . OR expr
    (54) expr -> expr . AND expr
    (55) expr -> expr . GREATEREQ expr
    (56) expr -> expr . LESSEQ expr
    (57) expr -> expr . NOTEQ expr
    (58) expr -> expr . EQEQ expr
    (60) expr -> expr . ? expr : expr
    SEP             reduce using rule 27 (var_assign -> var PLUSASGN expr .)
    {               reduce using rule 27 (var_assign -> var PLUSASGN expr .)
    LET             reduce using rule 27 (var_assign -> var PLUSASGN expr .)
    FALSE           reduce using rule 27 (var_assign -> var PLUSASGN expr .)
    TRUE            reduce using rule 27 (var_assign -> var PLUSASGN expr .)
    STRING          reduce using rule 27 (var_assign -> var PLUSASGN expr .)
    FLOAT           reduce using rule 27 (var_assign -> var PLUSASGN expr .)
    INT             reduce using rule 27 (var_assign -> var PLUSASGN expr .)
    (               reduce using rule 27 (var_assign -> var PLUSASGN expr .)
    !               reduce using rule 27 (var_assign -> var PLUSASGN expr .)
    ID              reduce using rule 27 (var_assign -> var PLUSASGN expr .)
    DEC             reduce using rule 27 (var_assign -> var PLUSASGN expr .)
    INC             reduce using rule 27 (var_assign -> var PLUSASGN expr .)
    IF              reduce using rule 27 (var_assign -> var PLUSASGN expr .)
    FOR             reduce using rule 27 (var_assign -> var PLUSASGN expr .)
    WHILE           reduce using rule 27 (var_assign -> var PLUSASGN expr .)
    RETURN          reduce using rule 27 (var_assign -> var PLUSASGN expr .)
    FN              reduce using rule 27 (var_assign -> var PLUSASGN expr .)
    %               shift and go to state 34
    /               shift and go to state 35
    *               shift and go to state 36
    -               shift and go to state 37
    +               shift and go to state 38
    |               shift and go to state 39
    ^               shift and go to state 40
    &               shift and go to state 41
    GREATER         shift and go to state 42
    LESS            shift and go to state 43
    OR              shift and go to state 44
    AND             shift and go to state 45
    GREATEREQ       shift and go to state 46
    LESSEQ          shift and go to state 47
    NOTEQ           shift and go to state 48
    EQEQ            shift and go to state 49
    ?               shift and go to state 50


state 99

    (28) var_assign -> var ASSIGN expr .
    (40) expr -> expr . % expr
    (41) expr -> expr . / expr
    (42) expr -> expr . * expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    (48) expr -> expr . | expr
    (49) expr -> expr . ^ expr
    (50) expr -> expr . & expr
    (51) expr -> expr . GREATER expr
    (52) expr -> expr . LESS expr
    (53) expr -> expr . OR expr
    (54) expr -> expr . AND expr
    (55) expr -> expr . GREATEREQ expr
    (56) expr -> expr . LESSEQ expr
    (57) expr -> expr . NOTEQ expr
    (58) expr -> expr . EQEQ expr
    (60) expr -> expr . ? expr : expr
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for + resolved as shift
    SEP             reduce using rule 28 (var_assign -> var ASSIGN expr .)
    {               reduce using rule 28 (var_assign -> var ASSIGN expr .)
    LET             reduce using rule 28 (var_assign -> var ASSIGN expr .)
    FALSE           reduce using rule 28 (var_assign -> var ASSIGN expr .)
    TRUE            reduce using rule 28 (var_assign -> var ASSIGN expr .)
    STRING          reduce using rule 28 (var_assign -> var ASSIGN expr .)
    FLOAT           reduce using rule 28 (var_assign -> var ASSIGN expr .)
    INT             reduce using rule 28 (var_assign -> var ASSIGN expr .)
    (               reduce using rule 28 (var_assign -> var ASSIGN expr .)
    !               reduce using rule 28 (var_assign -> var ASSIGN expr .)
    ID              reduce using rule 28 (var_assign -> var ASSIGN expr .)
    DEC             reduce using rule 28 (var_assign -> var ASSIGN expr .)
    INC             reduce using rule 28 (var_assign -> var ASSIGN expr .)
    IF              reduce using rule 28 (var_assign -> var ASSIGN expr .)
    FOR             reduce using rule 28 (var_assign -> var ASSIGN expr .)
    WHILE           reduce using rule 28 (var_assign -> var ASSIGN expr .)
    RETURN          reduce using rule 28 (var_assign -> var ASSIGN expr .)
    FN              reduce using rule 28 (var_assign -> var ASSIGN expr .)
    %               shift and go to state 34
    /               shift and go to state 35
    *               shift and go to state 36
    -               shift and go to state 37
    +               shift and go to state 38
    |               shift and go to state 39
    ^               shift and go to state 40
    &               shift and go to state 41
    GREATER         shift and go to state 42
    LESS            shift and go to state 43
    OR              shift and go to state 44
    AND             shift and go to state 45
    GREATEREQ       shift and go to state 46
    LESSEQ          shift and go to state 47
    NOTEQ           shift and go to state 48
    EQEQ            shift and go to state 49
    ?               shift and go to state 50


state 100

    (39) expr -> ( expr ) .
    SEP             reduce using rule 39 (expr -> ( expr ) .)
    %               reduce using rule 39 (expr -> ( expr ) .)
    /               reduce using rule 39 (expr -> ( expr ) .)
    *               reduce using rule 39 (expr -> ( expr ) .)
    -               reduce using rule 39 (expr -> ( expr ) .)
    +               reduce using rule 39 (expr -> ( expr ) .)
    |               reduce using rule 39 (expr -> ( expr ) .)
    ^               reduce using rule 39 (expr -> ( expr ) .)
    &               reduce using rule 39 (expr -> ( expr ) .)
    GREATER         reduce using rule 39 (expr -> ( expr ) .)
    LESS            reduce using rule 39 (expr -> ( expr ) .)
    OR              reduce using rule 39 (expr -> ( expr ) .)
    AND             reduce using rule 39 (expr -> ( expr ) .)
    GREATEREQ       reduce using rule 39 (expr -> ( expr ) .)
    LESSEQ          reduce using rule 39 (expr -> ( expr ) .)
    NOTEQ           reduce using rule 39 (expr -> ( expr ) .)
    EQEQ            reduce using rule 39 (expr -> ( expr ) .)
    ?               reduce using rule 39 (expr -> ( expr ) .)
    )               reduce using rule 39 (expr -> ( expr ) .)
    {               reduce using rule 39 (expr -> ( expr ) .)
    LET             reduce using rule 39 (expr -> ( expr ) .)
    FALSE           reduce using rule 39 (expr -> ( expr ) .)
    TRUE            reduce using rule 39 (expr -> ( expr ) .)
    STRING          reduce using rule 39 (expr -> ( expr ) .)
    FLOAT           reduce using rule 39 (expr -> ( expr ) .)
    INT             reduce using rule 39 (expr -> ( expr ) .)
    (               reduce using rule 39 (expr -> ( expr ) .)
    !               reduce using rule 39 (expr -> ( expr ) .)
    ID              reduce using rule 39 (expr -> ( expr ) .)
    DEC             reduce using rule 39 (expr -> ( expr ) .)
    INC             reduce using rule 39 (expr -> ( expr ) .)
    IF              reduce using rule 39 (expr -> ( expr ) .)
    FOR             reduce using rule 39 (expr -> ( expr ) .)
    WHILE           reduce using rule 39 (expr -> ( expr ) .)
    RETURN          reduce using rule 39 (expr -> ( expr ) .)
    FN              reduce using rule 39 (expr -> ( expr ) .)
    :               reduce using rule 39 (expr -> ( expr ) .)
    ,               reduce using rule 39 (expr -> ( expr ) .)


state 101

    (59) expr -> ID ( args . )
    (71) args -> args . , arg
    )               shift and go to state 121
    ,               shift and go to state 122


state 102

    (69) args -> empty .
    )               reduce using rule 69 (args -> empty .)
    ,               reduce using rule 69 (args -> empty .)


state 103

    (70) args -> arg .
    )               reduce using rule 70 (args -> arg .)
    ,               reduce using rule 70 (args -> arg .)


state 104

    (72) arg -> expr .
    (40) expr -> expr . % expr
    (41) expr -> expr . / expr
    (42) expr -> expr . * expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    (48) expr -> expr . | expr
    (49) expr -> expr . ^ expr
    (50) expr -> expr . & expr
    (51) expr -> expr . GREATER expr
    (52) expr -> expr . LESS expr
    (53) expr -> expr . OR expr
    (54) expr -> expr . AND expr
    (55) expr -> expr . GREATEREQ expr
    (56) expr -> expr . LESSEQ expr
    (57) expr -> expr . NOTEQ expr
    (58) expr -> expr . EQEQ expr
    (60) expr -> expr . ? expr : expr
    )               reduce using rule 72 (arg -> expr .)
    ,               reduce using rule 72 (arg -> expr .)
    %               shift and go to state 34
    /               shift and go to state 35
    *               shift and go to state 36
    -               shift and go to state 37
    +               shift and go to state 38
    |               shift and go to state 39
    ^               shift and go to state 40
    &               shift and go to state 41
    GREATER         shift and go to state 42
    LESS            shift and go to state 43
    OR              shift and go to state 44
    AND             shift and go to state 45
    GREATEREQ       shift and go to state 46
    LESSEQ          shift and go to state 47
    NOTEQ           shift and go to state 48
    EQEQ            shift and go to state 49
    ?               shift and go to state 50


state 105

    (29) if_statement -> IF expr block .
    (30) if_statement -> IF expr block . ELSE block
  ! shift/reduce conflict for ELSE resolved as shift
    LET             reduce using rule 29 (if_statement -> IF expr block .)
    FALSE           reduce using rule 29 (if_statement -> IF expr block .)
    TRUE            reduce using rule 29 (if_statement -> IF expr block .)
    STRING          reduce using rule 29 (if_statement -> IF expr block .)
    FLOAT           reduce using rule 29 (if_statement -> IF expr block .)
    INT             reduce using rule 29 (if_statement -> IF expr block .)
    (               reduce using rule 29 (if_statement -> IF expr block .)
    !               reduce using rule 29 (if_statement -> IF expr block .)
    +               reduce using rule 29 (if_statement -> IF expr block .)
    -               reduce using rule 29 (if_statement -> IF expr block .)
    ID              reduce using rule 29 (if_statement -> IF expr block .)
    DEC             reduce using rule 29 (if_statement -> IF expr block .)
    INC             reduce using rule 29 (if_statement -> IF expr block .)
    IF              reduce using rule 29 (if_statement -> IF expr block .)
    FOR             reduce using rule 29 (if_statement -> IF expr block .)
    WHILE           reduce using rule 29 (if_statement -> IF expr block .)
    RETURN          reduce using rule 29 (if_statement -> IF expr block .)
    FN              reduce using rule 29 (if_statement -> IF expr block .)
    $end            reduce using rule 29 (if_statement -> IF expr block .)
    }               reduce using rule 29 (if_statement -> IF expr block .)
    ELSE            shift and go to state 123


state 106

    (43) expr -> expr - . expr
    (47) expr -> - . expr
    (33) expr -> . var
    (34) expr -> . FALSE
    (35) expr -> . TRUE
    (36) expr -> . STRING
    (37) expr -> . FLOAT
    (38) expr -> . INT
    (39) expr -> . ( expr )
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ! expr
    (46) expr -> . + expr
    (47) expr -> . - expr
    (48) expr -> . expr | expr
    (49) expr -> . expr ^ expr
    (50) expr -> . expr & expr
    (51) expr -> . expr GREATER expr
    (52) expr -> . expr LESS expr
    (53) expr -> . expr OR expr
    (54) expr -> . expr AND expr
    (55) expr -> . expr GREATEREQ expr
    (56) expr -> . expr LESSEQ expr
    (57) expr -> . expr NOTEQ expr
    (58) expr -> . expr EQEQ expr
    (59) expr -> . ID ( args )
    (60) expr -> . expr ? expr : expr
    (61) var -> . ID
    FALSE           shift and go to state 15
    TRUE            shift and go to state 16
    STRING          shift and go to state 17
    FLOAT           shift and go to state 18
    INT             shift and go to state 19
    (               shift and go to state 20
    !               shift and go to state 23
    +               shift and go to state 22
    -               shift and go to state 21
    ID              shift and go to state 24

    expr                           shift and go to state 124
    var                            shift and go to state 62

state 107

    (44) expr -> expr + . expr
    (46) expr -> + . expr
    (33) expr -> . var
    (34) expr -> . FALSE
    (35) expr -> . TRUE
    (36) expr -> . STRING
    (37) expr -> . FLOAT
    (38) expr -> . INT
    (39) expr -> . ( expr )
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ! expr
    (46) expr -> . + expr
    (47) expr -> . - expr
    (48) expr -> . expr | expr
    (49) expr -> . expr ^ expr
    (50) expr -> . expr & expr
    (51) expr -> . expr GREATER expr
    (52) expr -> . expr LESS expr
    (53) expr -> . expr OR expr
    (54) expr -> . expr AND expr
    (55) expr -> . expr GREATEREQ expr
    (56) expr -> . expr LESSEQ expr
    (57) expr -> . expr NOTEQ expr
    (58) expr -> . expr EQEQ expr
    (59) expr -> . ID ( args )
    (60) expr -> . expr ? expr : expr
    (61) var -> . ID
    FALSE           shift and go to state 15
    TRUE            shift and go to state 16
    STRING          shift and go to state 17
    FLOAT           shift and go to state 18
    INT             shift and go to state 19
    (               shift and go to state 20
    !               shift and go to state 23
    +               shift and go to state 22
    -               shift and go to state 21
    ID              shift and go to state 24

    expr                           shift and go to state 125
    var                            shift and go to state 62

state 108

    (63) block -> statement .
    ELSE            reduce using rule 63 (block -> statement .)
    LET             reduce using rule 63 (block -> statement .)
    FALSE           reduce using rule 63 (block -> statement .)
    TRUE            reduce using rule 63 (block -> statement .)
    STRING          reduce using rule 63 (block -> statement .)
    FLOAT           reduce using rule 63 (block -> statement .)
    INT             reduce using rule 63 (block -> statement .)
    (               reduce using rule 63 (block -> statement .)
    !               reduce using rule 63 (block -> statement .)
    +               reduce using rule 63 (block -> statement .)
    -               reduce using rule 63 (block -> statement .)
    ID              reduce using rule 63 (block -> statement .)
    DEC             reduce using rule 63 (block -> statement .)
    INC             reduce using rule 63 (block -> statement .)
    IF              reduce using rule 63 (block -> statement .)
    FOR             reduce using rule 63 (block -> statement .)
    WHILE           reduce using rule 63 (block -> statement .)
    RETURN          reduce using rule 63 (block -> statement .)
    FN              reduce using rule 63 (block -> statement .)
    $end            reduce using rule 63 (block -> statement .)
    }               reduce using rule 63 (block -> statement .)


state 109

    (64) block -> { . program }
    (1) program -> . empty
    (2) program -> . statements
    (62) empty -> .
    (3) statements -> . statements statement
    (4) statements -> . statement
    (5) statement -> . expr SEP
    (6) statement -> . var_assign SEP
    (7) statement -> . LET var : var_type SEP
    (8) statement -> . var_define SEP
    (9) statement -> . if_statement
    (10) statement -> . for_statement
    (11) statement -> . while_statement
    (12) statement -> . return_statement
    (13) statement -> . function_definition
    (33) expr -> . var
    (34) expr -> . FALSE
    (35) expr -> . TRUE
    (36) expr -> . STRING
    (37) expr -> . FLOAT
    (38) expr -> . INT
    (39) expr -> . ( expr )
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ! expr
    (46) expr -> . + expr
    (47) expr -> . - expr
    (48) expr -> . expr | expr
    (49) expr -> . expr ^ expr
    (50) expr -> . expr & expr
    (51) expr -> . expr GREATER expr
    (52) expr -> . expr LESS expr
    (53) expr -> . expr OR expr
    (54) expr -> . expr AND expr
    (55) expr -> . expr GREATEREQ expr
    (56) expr -> . expr LESSEQ expr
    (57) expr -> . expr NOTEQ expr
    (58) expr -> . expr EQEQ expr
    (59) expr -> . ID ( args )
    (60) expr -> . expr ? expr : expr
    (21) var_assign -> . DEC var
    (22) var_assign -> . INC var
    (23) var_assign -> . var MODULOASGN expr
    (24) var_assign -> . var SLASHASGN expr
    (25) var_assign -> . var STARASGN expr
    (26) var_assign -> . var MINUSASGN expr
    (27) var_assign -> . var PLUSASGN expr
    (28) var_assign -> . var ASSIGN expr
    (19) var_define -> . LET var ASSIGN expr
    (29) if_statement -> . IF expr block
    (30) if_statement -> . IF expr block ELSE block
    (32) for_statement -> . FOR var_assign SEP expr SEP var_assign block
    (31) while_statement -> . WHILE expr block
    (20) return_statement -> . RETURN expr SEP
    (18) function_definition -> . FN ID ( params ) block
    (61) var -> . ID
    }               reduce using rule 62 (empty -> .)
    LET             shift and go to state 7
    FALSE           shift and go to state 15
    TRUE            shift and go to state 16
    STRING          shift and go to state 17
    FLOAT           shift and go to state 18
    INT             shift and go to state 19
    (               shift and go to state 20
    !               shift and go to state 23
    +               shift and go to state 22
    -               shift and go to state 21
    ID              shift and go to state 24
    DEC             shift and go to state 25
    INC             shift and go to state 26
    IF              shift and go to state 27
    FOR             shift and go to state 28
    WHILE           shift and go to state 29
    RETURN          shift and go to state 30
    FN              shift and go to state 31

    program                        shift and go to state 126
    empty                          shift and go to state 2
    statements                     shift and go to state 3
    statement                      shift and go to state 4
    expr                           shift and go to state 5
    var_assign                     shift and go to state 6
    var                            shift and go to state 8
    var_define                     shift and go to state 9
    if_statement                   shift and go to state 10
    for_statement                  shift and go to state 11
    while_statement                shift and go to state 12
    return_statement               shift and go to state 13
    function_definition            shift and go to state 14

state 110

    (32) for_statement -> FOR var_assign SEP . expr SEP var_assign block
    (33) expr -> . var
    (34) expr -> . FALSE
    (35) expr -> . TRUE
    (36) expr -> . STRING
    (37) expr -> . FLOAT
    (38) expr -> . INT
    (39) expr -> . ( expr )
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ! expr
    (46) expr -> . + expr
    (47) expr -> . - expr
    (48) expr -> . expr | expr
    (49) expr -> . expr ^ expr
    (50) expr -> . expr & expr
    (51) expr -> . expr GREATER expr
    (52) expr -> . expr LESS expr
    (53) expr -> . expr OR expr
    (54) expr -> . expr AND expr
    (55) expr -> . expr GREATEREQ expr
    (56) expr -> . expr LESSEQ expr
    (57) expr -> . expr NOTEQ expr
    (58) expr -> . expr EQEQ expr
    (59) expr -> . ID ( args )
    (60) expr -> . expr ? expr : expr
    (61) var -> . ID
    FALSE           shift and go to state 15
    TRUE            shift and go to state 16
    STRING          shift and go to state 17
    FLOAT           shift and go to state 18
    INT             shift and go to state 19
    (               shift and go to state 20
    !               shift and go to state 23
    +               shift and go to state 22
    -               shift and go to state 21
    ID              shift and go to state 24

    expr                           shift and go to state 127
    var                            shift and go to state 62

state 111

    (31) while_statement -> WHILE expr block .
    LET             reduce using rule 31 (while_statement -> WHILE expr block .)
    FALSE           reduce using rule 31 (while_statement -> WHILE expr block .)
    TRUE            reduce using rule 31 (while_statement -> WHILE expr block .)
    STRING          reduce using rule 31 (while_statement -> WHILE expr block .)
    FLOAT           reduce using rule 31 (while_statement -> WHILE expr block .)
    INT             reduce using rule 31 (while_statement -> WHILE expr block .)
    (               reduce using rule 31 (while_statement -> WHILE expr block .)
    !               reduce using rule 31 (while_statement -> WHILE expr block .)
    +               reduce using rule 31 (while_statement -> WHILE expr block .)
    -               reduce using rule 31 (while_statement -> WHILE expr block .)
    ID              reduce using rule 31 (while_statement -> WHILE expr block .)
    DEC             reduce using rule 31 (while_statement -> WHILE expr block .)
    INC             reduce using rule 31 (while_statement -> WHILE expr block .)
    IF              reduce using rule 31 (while_statement -> WHILE expr block .)
    FOR             reduce using rule 31 (while_statement -> WHILE expr block .)
    WHILE           reduce using rule 31 (while_statement -> WHILE expr block .)
    RETURN          reduce using rule 31 (while_statement -> WHILE expr block .)
    FN              reduce using rule 31 (while_statement -> WHILE expr block .)
    $end            reduce using rule 31 (while_statement -> WHILE expr block .)
    }               reduce using rule 31 (while_statement -> WHILE expr block .)
    ELSE            reduce using rule 31 (while_statement -> WHILE expr block .)


state 112

    (20) return_statement -> RETURN expr SEP .
    LET             reduce using rule 20 (return_statement -> RETURN expr SEP .)
    FALSE           reduce using rule 20 (return_statement -> RETURN expr SEP .)
    TRUE            reduce using rule 20 (return_statement -> RETURN expr SEP .)
    STRING          reduce using rule 20 (return_statement -> RETURN expr SEP .)
    FLOAT           reduce using rule 20 (return_statement -> RETURN expr SEP .)
    INT             reduce using rule 20 (return_statement -> RETURN expr SEP .)
    (               reduce using rule 20 (return_statement -> RETURN expr SEP .)
    !               reduce using rule 20 (return_statement -> RETURN expr SEP .)
    +               reduce using rule 20 (return_statement -> RETURN expr SEP .)
    -               reduce using rule 20 (return_statement -> RETURN expr SEP .)
    ID              reduce using rule 20 (return_statement -> RETURN expr SEP .)
    DEC             reduce using rule 20 (return_statement -> RETURN expr SEP .)
    INC             reduce using rule 20 (return_statement -> RETURN expr SEP .)
    IF              reduce using rule 20 (return_statement -> RETURN expr SEP .)
    FOR             reduce using rule 20 (return_statement -> RETURN expr SEP .)
    WHILE           reduce using rule 20 (return_statement -> RETURN expr SEP .)
    RETURN          reduce using rule 20 (return_statement -> RETURN expr SEP .)
    FN              reduce using rule 20 (return_statement -> RETURN expr SEP .)
    $end            reduce using rule 20 (return_statement -> RETURN expr SEP .)
    }               reduce using rule 20 (return_statement -> RETURN expr SEP .)
    ELSE            reduce using rule 20 (return_statement -> RETURN expr SEP .)


state 113

    (18) function_definition -> FN ID ( . params ) block
    (65) params -> . empty
    (66) params -> . param
    (67) params -> . params , param
    (62) empty -> .
    (68) param -> . ID : var_type
    )               reduce using rule 62 (empty -> .)
    ,               reduce using rule 62 (empty -> .)
    ID              shift and go to state 128

    params                         shift and go to state 129
    empty                          shift and go to state 130
    param                          shift and go to state 131

state 114

    (60) expr -> expr ? expr : . expr
    (33) expr -> . var
    (34) expr -> . FALSE
    (35) expr -> . TRUE
    (36) expr -> . STRING
    (37) expr -> . FLOAT
    (38) expr -> . INT
    (39) expr -> . ( expr )
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ! expr
    (46) expr -> . + expr
    (47) expr -> . - expr
    (48) expr -> . expr | expr
    (49) expr -> . expr ^ expr
    (50) expr -> . expr & expr
    (51) expr -> . expr GREATER expr
    (52) expr -> . expr LESS expr
    (53) expr -> . expr OR expr
    (54) expr -> . expr AND expr
    (55) expr -> . expr GREATEREQ expr
    (56) expr -> . expr LESSEQ expr
    (57) expr -> . expr NOTEQ expr
    (58) expr -> . expr EQEQ expr
    (59) expr -> . ID ( args )
    (60) expr -> . expr ? expr : expr
    (61) var -> . ID
    FALSE           shift and go to state 15
    TRUE            shift and go to state 16
    STRING          shift and go to state 17
    FLOAT           shift and go to state 18
    INT             shift and go to state 19
    (               shift and go to state 20
    !               shift and go to state 23
    +               shift and go to state 22
    -               shift and go to state 21
    ID              shift and go to state 24

    expr                           shift and go to state 132
    var                            shift and go to state 62

state 115

    (7) statement -> LET var : var_type . SEP
    SEP             shift and go to state 133


state 116

    (14) var_type -> BOOL_TYPE .
    SEP             reduce using rule 14 (var_type -> BOOL_TYPE .)
    )               reduce using rule 14 (var_type -> BOOL_TYPE .)
    ,               reduce using rule 14 (var_type -> BOOL_TYPE .)


state 117

    (15) var_type -> STRING_TYPE .
    SEP             reduce using rule 15 (var_type -> STRING_TYPE .)
    )               reduce using rule 15 (var_type -> STRING_TYPE .)
    ,               reduce using rule 15 (var_type -> STRING_TYPE .)


state 118

    (16) var_type -> FLOAT_TYPE .
    SEP             reduce using rule 16 (var_type -> FLOAT_TYPE .)
    )               reduce using rule 16 (var_type -> FLOAT_TYPE .)
    ,               reduce using rule 16 (var_type -> FLOAT_TYPE .)


state 119

    (17) var_type -> INT_TYPE .
    SEP             reduce using rule 17 (var_type -> INT_TYPE .)
    )               reduce using rule 17 (var_type -> INT_TYPE .)
    ,               reduce using rule 17 (var_type -> INT_TYPE .)


state 120

    (19) var_define -> LET var ASSIGN expr .
    (40) expr -> expr . % expr
    (41) expr -> expr . / expr
    (42) expr -> expr . * expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    (48) expr -> expr . | expr
    (49) expr -> expr . ^ expr
    (50) expr -> expr . & expr
    (51) expr -> expr . GREATER expr
    (52) expr -> expr . LESS expr
    (53) expr -> expr . OR expr
    (54) expr -> expr . AND expr
    (55) expr -> expr . GREATEREQ expr
    (56) expr -> expr . LESSEQ expr
    (57) expr -> expr . NOTEQ expr
    (58) expr -> expr . EQEQ expr
    (60) expr -> expr . ? expr : expr
    SEP             reduce using rule 19 (var_define -> LET var ASSIGN expr .)
    %               shift and go to state 34
    /               shift and go to state 35
    *               shift and go to state 36
    -               shift and go to state 37
    +               shift and go to state 38
    |               shift and go to state 39
    ^               shift and go to state 40
    &               shift and go to state 41
    GREATER         shift and go to state 42
    LESS            shift and go to state 43
    OR              shift and go to state 44
    AND             shift and go to state 45
    GREATEREQ       shift and go to state 46
    LESSEQ          shift and go to state 47
    NOTEQ           shift and go to state 48
    EQEQ            shift and go to state 49
    ?               shift and go to state 50


state 121

    (59) expr -> ID ( args ) .
    SEP             reduce using rule 59 (expr -> ID ( args ) .)
    %               reduce using rule 59 (expr -> ID ( args ) .)
    /               reduce using rule 59 (expr -> ID ( args ) .)
    *               reduce using rule 59 (expr -> ID ( args ) .)
    -               reduce using rule 59 (expr -> ID ( args ) .)
    +               reduce using rule 59 (expr -> ID ( args ) .)
    |               reduce using rule 59 (expr -> ID ( args ) .)
    ^               reduce using rule 59 (expr -> ID ( args ) .)
    &               reduce using rule 59 (expr -> ID ( args ) .)
    GREATER         reduce using rule 59 (expr -> ID ( args ) .)
    LESS            reduce using rule 59 (expr -> ID ( args ) .)
    OR              reduce using rule 59 (expr -> ID ( args ) .)
    AND             reduce using rule 59 (expr -> ID ( args ) .)
    GREATEREQ       reduce using rule 59 (expr -> ID ( args ) .)
    LESSEQ          reduce using rule 59 (expr -> ID ( args ) .)
    NOTEQ           reduce using rule 59 (expr -> ID ( args ) .)
    EQEQ            reduce using rule 59 (expr -> ID ( args ) .)
    ?               reduce using rule 59 (expr -> ID ( args ) .)
    )               reduce using rule 59 (expr -> ID ( args ) .)
    {               reduce using rule 59 (expr -> ID ( args ) .)
    LET             reduce using rule 59 (expr -> ID ( args ) .)
    FALSE           reduce using rule 59 (expr -> ID ( args ) .)
    TRUE            reduce using rule 59 (expr -> ID ( args ) .)
    STRING          reduce using rule 59 (expr -> ID ( args ) .)
    FLOAT           reduce using rule 59 (expr -> ID ( args ) .)
    INT             reduce using rule 59 (expr -> ID ( args ) .)
    (               reduce using rule 59 (expr -> ID ( args ) .)
    !               reduce using rule 59 (expr -> ID ( args ) .)
    ID              reduce using rule 59 (expr -> ID ( args ) .)
    DEC             reduce using rule 59 (expr -> ID ( args ) .)
    INC             reduce using rule 59 (expr -> ID ( args ) .)
    IF              reduce using rule 59 (expr -> ID ( args ) .)
    FOR             reduce using rule 59 (expr -> ID ( args ) .)
    WHILE           reduce using rule 59 (expr -> ID ( args ) .)
    RETURN          reduce using rule 59 (expr -> ID ( args ) .)
    FN              reduce using rule 59 (expr -> ID ( args ) .)
    :               reduce using rule 59 (expr -> ID ( args ) .)
    ,               reduce using rule 59 (expr -> ID ( args ) .)


state 122

    (71) args -> args , . arg
    (72) arg -> . expr
    (33) expr -> . var
    (34) expr -> . FALSE
    (35) expr -> . TRUE
    (36) expr -> . STRING
    (37) expr -> . FLOAT
    (38) expr -> . INT
    (39) expr -> . ( expr )
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ! expr
    (46) expr -> . + expr
    (47) expr -> . - expr
    (48) expr -> . expr | expr
    (49) expr -> . expr ^ expr
    (50) expr -> . expr & expr
    (51) expr -> . expr GREATER expr
    (52) expr -> . expr LESS expr
    (53) expr -> . expr OR expr
    (54) expr -> . expr AND expr
    (55) expr -> . expr GREATEREQ expr
    (56) expr -> . expr LESSEQ expr
    (57) expr -> . expr NOTEQ expr
    (58) expr -> . expr EQEQ expr
    (59) expr -> . ID ( args )
    (60) expr -> . expr ? expr : expr
    (61) var -> . ID
    FALSE           shift and go to state 15
    TRUE            shift and go to state 16
    STRING          shift and go to state 17
    FLOAT           shift and go to state 18
    INT             shift and go to state 19
    (               shift and go to state 20
    !               shift and go to state 23
    +               shift and go to state 22
    -               shift and go to state 21
    ID              shift and go to state 24

    arg                            shift and go to state 134
    expr                           shift and go to state 104
    var                            shift and go to state 62

state 123

    (30) if_statement -> IF expr block ELSE . block
    (63) block -> . statement
    (64) block -> . { program }
    (5) statement -> . expr SEP
    (6) statement -> . var_assign SEP
    (7) statement -> . LET var : var_type SEP
    (8) statement -> . var_define SEP
    (9) statement -> . if_statement
    (10) statement -> . for_statement
    (11) statement -> . while_statement
    (12) statement -> . return_statement
    (13) statement -> . function_definition
    (33) expr -> . var
    (34) expr -> . FALSE
    (35) expr -> . TRUE
    (36) expr -> . STRING
    (37) expr -> . FLOAT
    (38) expr -> . INT
    (39) expr -> . ( expr )
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ! expr
    (46) expr -> . + expr
    (47) expr -> . - expr
    (48) expr -> . expr | expr
    (49) expr -> . expr ^ expr
    (50) expr -> . expr & expr
    (51) expr -> . expr GREATER expr
    (52) expr -> . expr LESS expr
    (53) expr -> . expr OR expr
    (54) expr -> . expr AND expr
    (55) expr -> . expr GREATEREQ expr
    (56) expr -> . expr LESSEQ expr
    (57) expr -> . expr NOTEQ expr
    (58) expr -> . expr EQEQ expr
    (59) expr -> . ID ( args )
    (60) expr -> . expr ? expr : expr
    (21) var_assign -> . DEC var
    (22) var_assign -> . INC var
    (23) var_assign -> . var MODULOASGN expr
    (24) var_assign -> . var SLASHASGN expr
    (25) var_assign -> . var STARASGN expr
    (26) var_assign -> . var MINUSASGN expr
    (27) var_assign -> . var PLUSASGN expr
    (28) var_assign -> . var ASSIGN expr
    (19) var_define -> . LET var ASSIGN expr
    (29) if_statement -> . IF expr block
    (30) if_statement -> . IF expr block ELSE block
    (32) for_statement -> . FOR var_assign SEP expr SEP var_assign block
    (31) while_statement -> . WHILE expr block
    (20) return_statement -> . RETURN expr SEP
    (18) function_definition -> . FN ID ( params ) block
    (61) var -> . ID
    {               shift and go to state 109
    LET             shift and go to state 7
    FALSE           shift and go to state 15
    TRUE            shift and go to state 16
    STRING          shift and go to state 17
    FLOAT           shift and go to state 18
    INT             shift and go to state 19
    (               shift and go to state 20
    !               shift and go to state 23
    +               shift and go to state 22
    -               shift and go to state 21
    ID              shift and go to state 24
    DEC             shift and go to state 25
    INC             shift and go to state 26
    IF              shift and go to state 27
    FOR             shift and go to state 28
    WHILE           shift and go to state 29
    RETURN          shift and go to state 30
    FN              shift and go to state 31

    expr                           shift and go to state 5
    block                          shift and go to state 135
    statement                      shift and go to state 108
    var_assign                     shift and go to state 6
    var                            shift and go to state 8
    var_define                     shift and go to state 9
    if_statement                   shift and go to state 10
    for_statement                  shift and go to state 11
    while_statement                shift and go to state 12
    return_statement               shift and go to state 13
    function_definition            shift and go to state 14

state 124

    (43) expr -> expr - expr .
    (47) expr -> - expr .
    (40) expr -> expr . % expr
    (41) expr -> expr . / expr
    (42) expr -> expr . * expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    (48) expr -> expr . | expr
    (49) expr -> expr . ^ expr
    (50) expr -> expr . & expr
    (51) expr -> expr . GREATER expr
    (52) expr -> expr . LESS expr
    (53) expr -> expr . OR expr
    (54) expr -> expr . AND expr
    (55) expr -> expr . GREATEREQ expr
    (56) expr -> expr . LESSEQ expr
    (57) expr -> expr . NOTEQ expr
    (58) expr -> expr . EQEQ expr
    (60) expr -> expr . ? expr : expr
  ! reduce/reduce conflict for % resolved using rule 47 (expr -> - expr .)
  ! reduce/reduce conflict for / resolved using rule 47 (expr -> - expr .)
  ! reduce/reduce conflict for * resolved using rule 47 (expr -> - expr .)
  ! reduce/reduce conflict for - resolved using rule 47 (expr -> - expr .)
  ! reduce/reduce conflict for + resolved using rule 47 (expr -> - expr .)
  ! reduce/reduce conflict for | resolved using rule 47 (expr -> - expr .)
  ! reduce/reduce conflict for ^ resolved using rule 47 (expr -> - expr .)
  ! reduce/reduce conflict for & resolved using rule 47 (expr -> - expr .)
  ! reduce/reduce conflict for GREATER resolved using rule 47 (expr -> - expr .)
  ! reduce/reduce conflict for LESS resolved using rule 47 (expr -> - expr .)
  ! reduce/reduce conflict for OR resolved using rule 47 (expr -> - expr .)
  ! reduce/reduce conflict for AND resolved using rule 47 (expr -> - expr .)
  ! reduce/reduce conflict for GREATEREQ resolved using rule 47 (expr -> - expr .)
  ! reduce/reduce conflict for LESSEQ resolved using rule 47 (expr -> - expr .)
  ! reduce/reduce conflict for NOTEQ resolved using rule 47 (expr -> - expr .)
  ! reduce/reduce conflict for EQEQ resolved using rule 47 (expr -> - expr .)
  ! reduce/reduce conflict for ? resolved using rule 47 (expr -> - expr .)
    {               reduce using rule 43 (expr -> expr - expr .)
    LET             reduce using rule 43 (expr -> expr - expr .)
    FALSE           reduce using rule 43 (expr -> expr - expr .)
    TRUE            reduce using rule 43 (expr -> expr - expr .)
    STRING          reduce using rule 43 (expr -> expr - expr .)
    FLOAT           reduce using rule 43 (expr -> expr - expr .)
    INT             reduce using rule 43 (expr -> expr - expr .)
    (               reduce using rule 43 (expr -> expr - expr .)
    !               reduce using rule 43 (expr -> expr - expr .)
    ID              reduce using rule 43 (expr -> expr - expr .)
    DEC             reduce using rule 43 (expr -> expr - expr .)
    INC             reduce using rule 43 (expr -> expr - expr .)
    IF              reduce using rule 43 (expr -> expr - expr .)
    FOR             reduce using rule 43 (expr -> expr - expr .)
    WHILE           reduce using rule 43 (expr -> expr - expr .)
    RETURN          reduce using rule 43 (expr -> expr - expr .)
    FN              reduce using rule 43 (expr -> expr - expr .)
    SEP             reduce using rule 47 (expr -> - expr .)
    %               reduce using rule 47 (expr -> - expr .)
    /               reduce using rule 47 (expr -> - expr .)
    *               reduce using rule 47 (expr -> - expr .)
    -               reduce using rule 47 (expr -> - expr .)
    +               reduce using rule 47 (expr -> - expr .)
    |               reduce using rule 47 (expr -> - expr .)
    ^               reduce using rule 47 (expr -> - expr .)
    &               reduce using rule 47 (expr -> - expr .)
    GREATER         reduce using rule 47 (expr -> - expr .)
    LESS            reduce using rule 47 (expr -> - expr .)
    OR              reduce using rule 47 (expr -> - expr .)
    AND             reduce using rule 47 (expr -> - expr .)
    GREATEREQ       reduce using rule 47 (expr -> - expr .)
    LESSEQ          reduce using rule 47 (expr -> - expr .)
    NOTEQ           reduce using rule 47 (expr -> - expr .)
    EQEQ            reduce using rule 47 (expr -> - expr .)
    ?               reduce using rule 47 (expr -> - expr .)


state 125

    (44) expr -> expr + expr .
    (46) expr -> + expr .
    (40) expr -> expr . % expr
    (41) expr -> expr . / expr
    (42) expr -> expr . * expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    (48) expr -> expr . | expr
    (49) expr -> expr . ^ expr
    (50) expr -> expr . & expr
    (51) expr -> expr . GREATER expr
    (52) expr -> expr . LESS expr
    (53) expr -> expr . OR expr
    (54) expr -> expr . AND expr
    (55) expr -> expr . GREATEREQ expr
    (56) expr -> expr . LESSEQ expr
    (57) expr -> expr . NOTEQ expr
    (58) expr -> expr . EQEQ expr
    (60) expr -> expr . ? expr : expr
  ! reduce/reduce conflict for % resolved using rule 46 (expr -> + expr .)
  ! reduce/reduce conflict for / resolved using rule 46 (expr -> + expr .)
  ! reduce/reduce conflict for * resolved using rule 46 (expr -> + expr .)
  ! reduce/reduce conflict for - resolved using rule 46 (expr -> + expr .)
  ! reduce/reduce conflict for + resolved using rule 46 (expr -> + expr .)
  ! reduce/reduce conflict for | resolved using rule 46 (expr -> + expr .)
  ! reduce/reduce conflict for ^ resolved using rule 46 (expr -> + expr .)
  ! reduce/reduce conflict for & resolved using rule 46 (expr -> + expr .)
  ! reduce/reduce conflict for GREATER resolved using rule 46 (expr -> + expr .)
  ! reduce/reduce conflict for LESS resolved using rule 46 (expr -> + expr .)
  ! reduce/reduce conflict for OR resolved using rule 46 (expr -> + expr .)
  ! reduce/reduce conflict for AND resolved using rule 46 (expr -> + expr .)
  ! reduce/reduce conflict for GREATEREQ resolved using rule 46 (expr -> + expr .)
  ! reduce/reduce conflict for LESSEQ resolved using rule 46 (expr -> + expr .)
  ! reduce/reduce conflict for NOTEQ resolved using rule 46 (expr -> + expr .)
  ! reduce/reduce conflict for EQEQ resolved using rule 46 (expr -> + expr .)
  ! reduce/reduce conflict for ? resolved using rule 46 (expr -> + expr .)
    {               reduce using rule 44 (expr -> expr + expr .)
    LET             reduce using rule 44 (expr -> expr + expr .)
    FALSE           reduce using rule 44 (expr -> expr + expr .)
    TRUE            reduce using rule 44 (expr -> expr + expr .)
    STRING          reduce using rule 44 (expr -> expr + expr .)
    FLOAT           reduce using rule 44 (expr -> expr + expr .)
    INT             reduce using rule 44 (expr -> expr + expr .)
    (               reduce using rule 44 (expr -> expr + expr .)
    !               reduce using rule 44 (expr -> expr + expr .)
    ID              reduce using rule 44 (expr -> expr + expr .)
    DEC             reduce using rule 44 (expr -> expr + expr .)
    INC             reduce using rule 44 (expr -> expr + expr .)
    IF              reduce using rule 44 (expr -> expr + expr .)
    FOR             reduce using rule 44 (expr -> expr + expr .)
    WHILE           reduce using rule 44 (expr -> expr + expr .)
    RETURN          reduce using rule 44 (expr -> expr + expr .)
    FN              reduce using rule 44 (expr -> expr + expr .)
    SEP             reduce using rule 46 (expr -> + expr .)
    %               reduce using rule 46 (expr -> + expr .)
    /               reduce using rule 46 (expr -> + expr .)
    *               reduce using rule 46 (expr -> + expr .)
    -               reduce using rule 46 (expr -> + expr .)
    +               reduce using rule 46 (expr -> + expr .)
    |               reduce using rule 46 (expr -> + expr .)
    ^               reduce using rule 46 (expr -> + expr .)
    &               reduce using rule 46 (expr -> + expr .)
    GREATER         reduce using rule 46 (expr -> + expr .)
    LESS            reduce using rule 46 (expr -> + expr .)
    OR              reduce using rule 46 (expr -> + expr .)
    AND             reduce using rule 46 (expr -> + expr .)
    GREATEREQ       reduce using rule 46 (expr -> + expr .)
    LESSEQ          reduce using rule 46 (expr -> + expr .)
    NOTEQ           reduce using rule 46 (expr -> + expr .)
    EQEQ            reduce using rule 46 (expr -> + expr .)
    ?               reduce using rule 46 (expr -> + expr .)


state 126

    (64) block -> { program . }
    }               shift and go to state 136


state 127

    (32) for_statement -> FOR var_assign SEP expr . SEP var_assign block
    (40) expr -> expr . % expr
    (41) expr -> expr . / expr
    (42) expr -> expr . * expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    (48) expr -> expr . | expr
    (49) expr -> expr . ^ expr
    (50) expr -> expr . & expr
    (51) expr -> expr . GREATER expr
    (52) expr -> expr . LESS expr
    (53) expr -> expr . OR expr
    (54) expr -> expr . AND expr
    (55) expr -> expr . GREATEREQ expr
    (56) expr -> expr . LESSEQ expr
    (57) expr -> expr . NOTEQ expr
    (58) expr -> expr . EQEQ expr
    (60) expr -> expr . ? expr : expr
    SEP             shift and go to state 137
    %               shift and go to state 34
    /               shift and go to state 35
    *               shift and go to state 36
    -               shift and go to state 37
    +               shift and go to state 38
    |               shift and go to state 39
    ^               shift and go to state 40
    &               shift and go to state 41
    GREATER         shift and go to state 42
    LESS            shift and go to state 43
    OR              shift and go to state 44
    AND             shift and go to state 45
    GREATEREQ       shift and go to state 46
    LESSEQ          shift and go to state 47
    NOTEQ           shift and go to state 48
    EQEQ            shift and go to state 49
    ?               shift and go to state 50


state 128

    (68) param -> ID . : var_type
    :               shift and go to state 138


state 129

    (18) function_definition -> FN ID ( params . ) block
    (67) params -> params . , param
    )               shift and go to state 139
    ,               shift and go to state 140


state 130

    (65) params -> empty .
    )               reduce using rule 65 (params -> empty .)
    ,               reduce using rule 65 (params -> empty .)


state 131

    (66) params -> param .
    )               reduce using rule 66 (params -> param .)
    ,               reduce using rule 66 (params -> param .)


state 132

    (60) expr -> expr ? expr : expr .
    (40) expr -> expr . % expr
    (41) expr -> expr . / expr
    (42) expr -> expr . * expr
    (43) expr -> expr . - expr
    (44) expr -> expr . + expr
    (48) expr -> expr . | expr
    (49) expr -> expr . ^ expr
    (50) expr -> expr . & expr
    (51) expr -> expr . GREATER expr
    (52) expr -> expr . LESS expr
    (53) expr -> expr . OR expr
    (54) expr -> expr . AND expr
    (55) expr -> expr . GREATEREQ expr
    (56) expr -> expr . LESSEQ expr
    (57) expr -> expr . NOTEQ expr
    (58) expr -> expr . EQEQ expr
    (60) expr -> expr . ? expr : expr
  ! shift/reduce conflict for % resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for | resolved as shift
  ! shift/reduce conflict for ^ resolved as shift
  ! shift/reduce conflict for & resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for GREATEREQ resolved as shift
  ! shift/reduce conflict for LESSEQ resolved as shift
  ! shift/reduce conflict for NOTEQ resolved as shift
  ! shift/reduce conflict for EQEQ resolved as shift
  ! shift/reduce conflict for ? resolved as shift
    SEP             reduce using rule 60 (expr -> expr ? expr : expr .)
    )               reduce using rule 60 (expr -> expr ? expr : expr .)
    {               reduce using rule 60 (expr -> expr ? expr : expr .)
    LET             reduce using rule 60 (expr -> expr ? expr : expr .)
    FALSE           reduce using rule 60 (expr -> expr ? expr : expr .)
    TRUE            reduce using rule 60 (expr -> expr ? expr : expr .)
    STRING          reduce using rule 60 (expr -> expr ? expr : expr .)
    FLOAT           reduce using rule 60 (expr -> expr ? expr : expr .)
    INT             reduce using rule 60 (expr -> expr ? expr : expr .)
    (               reduce using rule 60 (expr -> expr ? expr : expr .)
    !               reduce using rule 60 (expr -> expr ? expr : expr .)
    ID              reduce using rule 60 (expr -> expr ? expr : expr .)
    DEC             reduce using rule 60 (expr -> expr ? expr : expr .)
    INC             reduce using rule 60 (expr -> expr ? expr : expr .)
    IF              reduce using rule 60 (expr -> expr ? expr : expr .)
    FOR             reduce using rule 60 (expr -> expr ? expr : expr .)
    WHILE           reduce using rule 60 (expr -> expr ? expr : expr .)
    RETURN          reduce using rule 60 (expr -> expr ? expr : expr .)
    FN              reduce using rule 60 (expr -> expr ? expr : expr .)
    :               reduce using rule 60 (expr -> expr ? expr : expr .)
    ,               reduce using rule 60 (expr -> expr ? expr : expr .)
    %               shift and go to state 34
    /               shift and go to state 35
    *               shift and go to state 36
    -               shift and go to state 37
    +               shift and go to state 38
    |               shift and go to state 39
    ^               shift and go to state 40
    &               shift and go to state 41
    GREATER         shift and go to state 42
    LESS            shift and go to state 43
    OR              shift and go to state 44
    AND             shift and go to state 45
    GREATEREQ       shift and go to state 46
    LESSEQ          shift and go to state 47
    NOTEQ           shift and go to state 48
    EQEQ            shift and go to state 49
    ?               shift and go to state 50


state 133

    (7) statement -> LET var : var_type SEP .
    LET             reduce using rule 7 (statement -> LET var : var_type SEP .)
    FALSE           reduce using rule 7 (statement -> LET var : var_type SEP .)
    TRUE            reduce using rule 7 (statement -> LET var : var_type SEP .)
    STRING          reduce using rule 7 (statement -> LET var : var_type SEP .)
    FLOAT           reduce using rule 7 (statement -> LET var : var_type SEP .)
    INT             reduce using rule 7 (statement -> LET var : var_type SEP .)
    (               reduce using rule 7 (statement -> LET var : var_type SEP .)
    !               reduce using rule 7 (statement -> LET var : var_type SEP .)
    +               reduce using rule 7 (statement -> LET var : var_type SEP .)
    -               reduce using rule 7 (statement -> LET var : var_type SEP .)
    ID              reduce using rule 7 (statement -> LET var : var_type SEP .)
    DEC             reduce using rule 7 (statement -> LET var : var_type SEP .)
    INC             reduce using rule 7 (statement -> LET var : var_type SEP .)
    IF              reduce using rule 7 (statement -> LET var : var_type SEP .)
    FOR             reduce using rule 7 (statement -> LET var : var_type SEP .)
    WHILE           reduce using rule 7 (statement -> LET var : var_type SEP .)
    RETURN          reduce using rule 7 (statement -> LET var : var_type SEP .)
    FN              reduce using rule 7 (statement -> LET var : var_type SEP .)
    $end            reduce using rule 7 (statement -> LET var : var_type SEP .)
    }               reduce using rule 7 (statement -> LET var : var_type SEP .)
    ELSE            reduce using rule 7 (statement -> LET var : var_type SEP .)


state 134

    (71) args -> args , arg .
    )               reduce using rule 71 (args -> args , arg .)
    ,               reduce using rule 71 (args -> args , arg .)


state 135

    (30) if_statement -> IF expr block ELSE block .
    LET             reduce using rule 30 (if_statement -> IF expr block ELSE block .)
    FALSE           reduce using rule 30 (if_statement -> IF expr block ELSE block .)
    TRUE            reduce using rule 30 (if_statement -> IF expr block ELSE block .)
    STRING          reduce using rule 30 (if_statement -> IF expr block ELSE block .)
    FLOAT           reduce using rule 30 (if_statement -> IF expr block ELSE block .)
    INT             reduce using rule 30 (if_statement -> IF expr block ELSE block .)
    (               reduce using rule 30 (if_statement -> IF expr block ELSE block .)
    !               reduce using rule 30 (if_statement -> IF expr block ELSE block .)
    +               reduce using rule 30 (if_statement -> IF expr block ELSE block .)
    -               reduce using rule 30 (if_statement -> IF expr block ELSE block .)
    ID              reduce using rule 30 (if_statement -> IF expr block ELSE block .)
    DEC             reduce using rule 30 (if_statement -> IF expr block ELSE block .)
    INC             reduce using rule 30 (if_statement -> IF expr block ELSE block .)
    IF              reduce using rule 30 (if_statement -> IF expr block ELSE block .)
    FOR             reduce using rule 30 (if_statement -> IF expr block ELSE block .)
    WHILE           reduce using rule 30 (if_statement -> IF expr block ELSE block .)
    RETURN          reduce using rule 30 (if_statement -> IF expr block ELSE block .)
    FN              reduce using rule 30 (if_statement -> IF expr block ELSE block .)
    $end            reduce using rule 30 (if_statement -> IF expr block ELSE block .)
    }               reduce using rule 30 (if_statement -> IF expr block ELSE block .)
    ELSE            reduce using rule 30 (if_statement -> IF expr block ELSE block .)


state 136

    (64) block -> { program } .
    ELSE            reduce using rule 64 (block -> { program } .)
    LET             reduce using rule 64 (block -> { program } .)
    FALSE           reduce using rule 64 (block -> { program } .)
    TRUE            reduce using rule 64 (block -> { program } .)
    STRING          reduce using rule 64 (block -> { program } .)
    FLOAT           reduce using rule 64 (block -> { program } .)
    INT             reduce using rule 64 (block -> { program } .)
    (               reduce using rule 64 (block -> { program } .)
    !               reduce using rule 64 (block -> { program } .)
    +               reduce using rule 64 (block -> { program } .)
    -               reduce using rule 64 (block -> { program } .)
    ID              reduce using rule 64 (block -> { program } .)
    DEC             reduce using rule 64 (block -> { program } .)
    INC             reduce using rule 64 (block -> { program } .)
    IF              reduce using rule 64 (block -> { program } .)
    FOR             reduce using rule 64 (block -> { program } .)
    WHILE           reduce using rule 64 (block -> { program } .)
    RETURN          reduce using rule 64 (block -> { program } .)
    FN              reduce using rule 64 (block -> { program } .)
    $end            reduce using rule 64 (block -> { program } .)
    }               reduce using rule 64 (block -> { program } .)


state 137

    (32) for_statement -> FOR var_assign SEP expr SEP . var_assign block
    (21) var_assign -> . DEC var
    (22) var_assign -> . INC var
    (23) var_assign -> . var MODULOASGN expr
    (24) var_assign -> . var SLASHASGN expr
    (25) var_assign -> . var STARASGN expr
    (26) var_assign -> . var MINUSASGN expr
    (27) var_assign -> . var PLUSASGN expr
    (28) var_assign -> . var ASSIGN expr
    (61) var -> . ID
    DEC             shift and go to state 25
    INC             shift and go to state 26
    ID              shift and go to state 53

    var_assign                     shift and go to state 141
    var                            shift and go to state 71

state 138

    (68) param -> ID : . var_type
    (14) var_type -> . BOOL_TYPE
    (15) var_type -> . STRING_TYPE
    (16) var_type -> . FLOAT_TYPE
    (17) var_type -> . INT_TYPE
    BOOL_TYPE       shift and go to state 116
    STRING_TYPE     shift and go to state 117
    FLOAT_TYPE      shift and go to state 118
    INT_TYPE        shift and go to state 119

    var_type                       shift and go to state 142

state 139

    (18) function_definition -> FN ID ( params ) . block
    (63) block -> . statement
    (64) block -> . { program }
    (5) statement -> . expr SEP
    (6) statement -> . var_assign SEP
    (7) statement -> . LET var : var_type SEP
    (8) statement -> . var_define SEP
    (9) statement -> . if_statement
    (10) statement -> . for_statement
    (11) statement -> . while_statement
    (12) statement -> . return_statement
    (13) statement -> . function_definition
    (33) expr -> . var
    (34) expr -> . FALSE
    (35) expr -> . TRUE
    (36) expr -> . STRING
    (37) expr -> . FLOAT
    (38) expr -> . INT
    (39) expr -> . ( expr )
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ! expr
    (46) expr -> . + expr
    (47) expr -> . - expr
    (48) expr -> . expr | expr
    (49) expr -> . expr ^ expr
    (50) expr -> . expr & expr
    (51) expr -> . expr GREATER expr
    (52) expr -> . expr LESS expr
    (53) expr -> . expr OR expr
    (54) expr -> . expr AND expr
    (55) expr -> . expr GREATEREQ expr
    (56) expr -> . expr LESSEQ expr
    (57) expr -> . expr NOTEQ expr
    (58) expr -> . expr EQEQ expr
    (59) expr -> . ID ( args )
    (60) expr -> . expr ? expr : expr
    (21) var_assign -> . DEC var
    (22) var_assign -> . INC var
    (23) var_assign -> . var MODULOASGN expr
    (24) var_assign -> . var SLASHASGN expr
    (25) var_assign -> . var STARASGN expr
    (26) var_assign -> . var MINUSASGN expr
    (27) var_assign -> . var PLUSASGN expr
    (28) var_assign -> . var ASSIGN expr
    (19) var_define -> . LET var ASSIGN expr
    (29) if_statement -> . IF expr block
    (30) if_statement -> . IF expr block ELSE block
    (32) for_statement -> . FOR var_assign SEP expr SEP var_assign block
    (31) while_statement -> . WHILE expr block
    (20) return_statement -> . RETURN expr SEP
    (18) function_definition -> . FN ID ( params ) block
    (61) var -> . ID
    {               shift and go to state 109
    LET             shift and go to state 7
    FALSE           shift and go to state 15
    TRUE            shift and go to state 16
    STRING          shift and go to state 17
    FLOAT           shift and go to state 18
    INT             shift and go to state 19
    (               shift and go to state 20
    !               shift and go to state 23
    +               shift and go to state 22
    -               shift and go to state 21
    ID              shift and go to state 24
    DEC             shift and go to state 25
    INC             shift and go to state 26
    IF              shift and go to state 27
    FOR             shift and go to state 28
    WHILE           shift and go to state 29
    RETURN          shift and go to state 30
    FN              shift and go to state 31

    block                          shift and go to state 143
    statement                      shift and go to state 108
    expr                           shift and go to state 5
    var_assign                     shift and go to state 6
    var                            shift and go to state 8
    var_define                     shift and go to state 9
    if_statement                   shift and go to state 10
    for_statement                  shift and go to state 11
    while_statement                shift and go to state 12
    return_statement               shift and go to state 13
    function_definition            shift and go to state 14

state 140

    (67) params -> params , . param
    (68) param -> . ID : var_type
    ID              shift and go to state 128

    param                          shift and go to state 144

state 141

    (32) for_statement -> FOR var_assign SEP expr SEP var_assign . block
    (63) block -> . statement
    (64) block -> . { program }
    (5) statement -> . expr SEP
    (6) statement -> . var_assign SEP
    (7) statement -> . LET var : var_type SEP
    (8) statement -> . var_define SEP
    (9) statement -> . if_statement
    (10) statement -> . for_statement
    (11) statement -> . while_statement
    (12) statement -> . return_statement
    (13) statement -> . function_definition
    (33) expr -> . var
    (34) expr -> . FALSE
    (35) expr -> . TRUE
    (36) expr -> . STRING
    (37) expr -> . FLOAT
    (38) expr -> . INT
    (39) expr -> . ( expr )
    (40) expr -> . expr % expr
    (41) expr -> . expr / expr
    (42) expr -> . expr * expr
    (43) expr -> . expr - expr
    (44) expr -> . expr + expr
    (45) expr -> . ! expr
    (46) expr -> . + expr
    (47) expr -> . - expr
    (48) expr -> . expr | expr
    (49) expr -> . expr ^ expr
    (50) expr -> . expr & expr
    (51) expr -> . expr GREATER expr
    (52) expr -> . expr LESS expr
    (53) expr -> . expr OR expr
    (54) expr -> . expr AND expr
    (55) expr -> . expr GREATEREQ expr
    (56) expr -> . expr LESSEQ expr
    (57) expr -> . expr NOTEQ expr
    (58) expr -> . expr EQEQ expr
    (59) expr -> . ID ( args )
    (60) expr -> . expr ? expr : expr
    (21) var_assign -> . DEC var
    (22) var_assign -> . INC var
    (23) var_assign -> . var MODULOASGN expr
    (24) var_assign -> . var SLASHASGN expr
    (25) var_assign -> . var STARASGN expr
    (26) var_assign -> . var MINUSASGN expr
    (27) var_assign -> . var PLUSASGN expr
    (28) var_assign -> . var ASSIGN expr
    (19) var_define -> . LET var ASSIGN expr
    (29) if_statement -> . IF expr block
    (30) if_statement -> . IF expr block ELSE block
    (32) for_statement -> . FOR var_assign SEP expr SEP var_assign block
    (31) while_statement -> . WHILE expr block
    (20) return_statement -> . RETURN expr SEP
    (18) function_definition -> . FN ID ( params ) block
    (61) var -> . ID
    {               shift and go to state 109
    LET             shift and go to state 7
    FALSE           shift and go to state 15
    TRUE            shift and go to state 16
    STRING          shift and go to state 17
    FLOAT           shift and go to state 18
    INT             shift and go to state 19
    (               shift and go to state 20
    !               shift and go to state 23
    +               shift and go to state 22
    -               shift and go to state 21
    ID              shift and go to state 24
    DEC             shift and go to state 25
    INC             shift and go to state 26
    IF              shift and go to state 27
    FOR             shift and go to state 28
    WHILE           shift and go to state 29
    RETURN          shift and go to state 30
    FN              shift and go to state 31

    var_assign                     shift and go to state 6
    expr                           shift and go to state 5
    block                          shift and go to state 145
    statement                      shift and go to state 108
    var                            shift and go to state 8
    var_define                     shift and go to state 9
    if_statement                   shift and go to state 10
    for_statement                  shift and go to state 11
    while_statement                shift and go to state 12
    return_statement               shift and go to state 13
    function_definition            shift and go to state 14

state 142

    (68) param -> ID : var_type .
    )               reduce using rule 68 (param -> ID : var_type .)
    ,               reduce using rule 68 (param -> ID : var_type .)


state 143

    (18) function_definition -> FN ID ( params ) block .
    LET             reduce using rule 18 (function_definition -> FN ID ( params ) block .)
    FALSE           reduce using rule 18 (function_definition -> FN ID ( params ) block .)
    TRUE            reduce using rule 18 (function_definition -> FN ID ( params ) block .)
    STRING          reduce using rule 18 (function_definition -> FN ID ( params ) block .)
    FLOAT           reduce using rule 18 (function_definition -> FN ID ( params ) block .)
    INT             reduce using rule 18 (function_definition -> FN ID ( params ) block .)
    (               reduce using rule 18 (function_definition -> FN ID ( params ) block .)
    !               reduce using rule 18 (function_definition -> FN ID ( params ) block .)
    +               reduce using rule 18 (function_definition -> FN ID ( params ) block .)
    -               reduce using rule 18 (function_definition -> FN ID ( params ) block .)
    ID              reduce using rule 18 (function_definition -> FN ID ( params ) block .)
    DEC             reduce using rule 18 (function_definition -> FN ID ( params ) block .)
    INC             reduce using rule 18 (function_definition -> FN ID ( params ) block .)
    IF              reduce using rule 18 (function_definition -> FN ID ( params ) block .)
    FOR             reduce using rule 18 (function_definition -> FN ID ( params ) block .)
    WHILE           reduce using rule 18 (function_definition -> FN ID ( params ) block .)
    RETURN          reduce using rule 18 (function_definition -> FN ID ( params ) block .)
    FN              reduce using rule 18 (function_definition -> FN ID ( params ) block .)
    $end            reduce using rule 18 (function_definition -> FN ID ( params ) block .)
    }               reduce using rule 18 (function_definition -> FN ID ( params ) block .)
    ELSE            reduce using rule 18 (function_definition -> FN ID ( params ) block .)


state 144

    (67) params -> params , param .
    )               reduce using rule 67 (params -> params , param .)
    ,               reduce using rule 67 (params -> params , param .)


state 145

    (32) for_statement -> FOR var_assign SEP expr SEP var_assign block .
    LET             reduce using rule 32 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    FALSE           reduce using rule 32 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    TRUE            reduce using rule 32 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    STRING          reduce using rule 32 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    FLOAT           reduce using rule 32 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    INT             reduce using rule 32 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    (               reduce using rule 32 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    !               reduce using rule 32 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    +               reduce using rule 32 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    -               reduce using rule 32 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    ID              reduce using rule 32 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    DEC             reduce using rule 32 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    INC             reduce using rule 32 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    IF              reduce using rule 32 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    FOR             reduce using rule 32 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    WHILE           reduce using rule 32 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    RETURN          reduce using rule 32 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    FN              reduce using rule 32 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    $end            reduce using rule 32 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    }               reduce using rule 32 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    ELSE            reduce using rule 32 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)


Conflicts:

shift/reduce conflict for ( in state 24 resolved as shift
shift/reduce conflict for - in state 99 resolved as shift
shift/reduce conflict for + in state 99 resolved as shift
shift/reduce conflict for ELSE in state 105 resolved as shift
shift/reduce conflict for % in state 132 resolved as shift
shift/reduce conflict for / in state 132 resolved as shift
shift/reduce conflict for * in state 132 resolved as shift
shift/reduce conflict for - in state 132 resolved as shift
shift/reduce conflict for + in state 132 resolved as shift
shift/reduce conflict for | in state 132 resolved as shift
shift/reduce conflict for ^ in state 132 resolved as shift
shift/reduce conflict for & in state 132 resolved as shift
shift/reduce conflict for GREATER in state 132 resolved as shift
shift/reduce conflict for LESS in state 132 resolved as shift
shift/reduce conflict for OR in state 132 resolved as shift
shift/reduce conflict for AND in state 132 resolved as shift
shift/reduce conflict for GREATEREQ in state 132 resolved as shift
shift/reduce conflict for LESSEQ in state 132 resolved as shift
shift/reduce conflict for NOTEQ in state 132 resolved as shift
shift/reduce conflict for EQEQ in state 132 resolved as shift
shift/reduce conflict for ? in state 132 resolved as shift
reduce/reduce conflict in state 124 resolved using rule expr -> - expr  [precedence=right, level=11]
rejected rule (expr -> expr - expr  [precedence=left, level=9]) in state 124
reduce/reduce conflict in state 125 resolved using rule expr -> + expr  [precedence=right, level=11]
rejected rule (expr -> expr + expr  [precedence=left, level=9]) in state 125